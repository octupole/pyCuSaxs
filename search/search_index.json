{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyCuSAXS - CUDA-Accelerated SAXS Analysis","text":"<p>pyCuSAXS is a high-performance CUDA-accelerated pipeline for computing Small-Angle X-ray Scattering (SAXS) profiles from molecular dynamics trajectories. It combines a GPU-optimized C++/CUDA backend with Python-based trajectory processing, offering both command-line and graphical user interfaces.</p>"},{"location":"#what-is-small-angle-x-ray-scattering-saxs","title":"\ud83d\udd2c What is Small-Angle X-ray Scattering (SAXS)?","text":"<p>Small-Angle X-ray Scattering is an experimental technique used to study the structure of materials at the nanometer scale. In molecular biology and biophysics, SAXS provides crucial information about:</p> <ul> <li>Protein structure and dynamics in solution</li> <li>Conformational changes during molecular dynamics simulations</li> <li>Validation of MD simulations against experimental data</li> <li>Ensemble properties of flexible biomolecules</li> </ul> <p>pyCuSAXS bridges the gap between MD simulations and experimental SAXS by computing theoretical scattering profiles directly from trajectories, enabling:</p> <ul> <li>Direct comparison with experimental SAXS curves</li> <li>Validation of simulation force fields and parameters</li> <li>Analysis of conformational ensembles</li> <li>Time-resolved structural changes across MD trajectories</li> </ul>"},{"location":"#whats-in-this-package","title":"\ud83d\udce6 What's in This Package?","text":"<p>pyCuSAXS provides a complete toolkit for SAXS analysis:</p> <ul> <li>GPU-Accelerated Backend: Optimized C++/CUDA code for high-performance calculations</li> <li>Python Interface: Easy-to-use API integrated with MDAnalysis for trajectory handling</li> <li>Command-Line Tool: Batch processing and scripting support</li> <li>Graphical Interface: Interactive PySide6-based GUI for exploratory analysis</li> <li>Flexible Configuration: Extensive parameters for customizing calculations</li> <li>Production Ready: Comprehensive validation, error handling, and memory safety</li> </ul>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li> <p> GPU-Accelerated Computing</p> <p>Leverages NVIDIA CUDA for high-performance SAXS calculations with 15-30% performance improvements in recent optimizations</p> </li> <li> <p> MDAnalysis Integration</p> <p>Native support for GROMACS and other MD trajectory formats with streaming processing</p> </li> <li> <p> Dual Interface</p> <p>Command-line tool and beautiful PySide6-based GUI for flexible workflows</p> </li> <li> <p> Production Ready</p> <p>Comprehensive input validation, error handling, and exception translation</p> </li> <li> <p> Memory Efficient</p> <p>Streaming trajectory processing with double-buffered frame loading</p> </li> <li> <p> Flexible Configuration</p> <p>Extensive parameters for grid sizing, histogram binning, and solvent modeling</p> </li> </ul>"},{"location":"#installation","title":"\ud83d\udcbb Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before installing pyCuSAXS, ensure you have:</p> <ul> <li>NVIDIA GPU with CUDA Compute Capability 5.0 or higher</li> <li>CUDA Toolkit 11.0 or later (download here)</li> <li>Python 3.9 or later</li> <li>C++ compiler with C++17 support (GCC 7+, Clang 5+, or MSVC 2019+)</li> <li>CMake 3.18 or later</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code># Clone the repository\ngit clone https://github.com/octupole/pyCuSaxs.git\ncd pyCuSaxs\n\n# Install Python dependencies\npip install -r requirements.txt\n\n# Build and install pyCuSAXS\npip install .\n</code></pre> <p>For detailed installation instructions including troubleshooting, see the Installation Guide.</p>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":""},{"location":"#command-line-interface","title":"Command-Line Interface","text":"<p>Run a SAXS calculation on your MD trajectory:</p> <pre><code>python -m pycusaxs.main \\\n    --topology system.tpr \\\n    --trajectory trajectory.xtc \\\n    --grid 128,128,128 \\\n    --begin 0 --end 100 --dt 10 \\\n    --out saxs_profile.dat\n</code></pre>"},{"location":"#graphical-interface","title":"Graphical Interface","text":"<p>Launch the interactive GUI:</p> <pre><code>saxs-widget\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<p>Use pyCuSAXS in your Python scripts:</p> <pre><code>from pycusaxs.main import cuda_connect\n\nresult = cuda_connect(\n    topology=\"system.tpr\",\n    trajectory=\"trajectory.xtc\",\n    grid=[128, 128, 128],\n    begin=0,\n    end=100,\n    dt=10\n)\n\n# Access results\nprint(f\"SAXS profile: {result['output_file']}\")\n</code></pre> <p>For more examples, see the Quick Start Guide.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li> <p> Installation Guide</p> <p>Step-by-step installation instructions for all platforms</p> </li> <li> <p> Quick Start</p> <p>Get up and running in minutes with examples</p> </li> <li> <p> User Guide</p> <p>Complete CLI, GUI, and Python API documentation</p> </li> <li> <p> API Reference</p> <p>Detailed C++/CUDA and Python API documentation</p> </li> </ul>"},{"location":"#performance","title":"\ud83d\udcc8 Performance","text":"<p>Recent optimizations (v0.1.0):</p> <ul> <li>15-30% throughput improvement for multi-frame trajectories</li> <li>Reduced GPU synchronization from 10 to 2 calls per frame</li> <li>Fixed critical memory leaks and resource management issues</li> <li>Enhanced numerical stability and bounds checking</li> </ul> <p>Typical performance on NVIDIA RTX 3080:</p> System Size Grid Frames Time/Frame Total Time 50K atoms 64\u00b3 1000 ~15 ms ~15 sec 50K atoms 128\u00b3 1000 ~35 ms ~35 sec 200K atoms 128\u00b3 1000 ~85 ms ~85 sec"},{"location":"#algorithm","title":"\ud83e\uddea Algorithm","text":"<p>pyCuSAXS implements the SAXS intensity calculation:</p> \\[ I(q) = |F(q)|^2 = \\left|\\sum_j f_j(q) \\exp(iq \\cdot r_j)\\right|^2 \\] <p>Where:</p> <ul> <li>\\(f_j(q)\\): Atomic form factor</li> <li>\\(r_j\\): Atomic position</li> <li>\\(q\\): Scattering vector</li> </ul> <p>The pipeline:</p> <ol> <li>Coordinate Transformation - Convert triclinic box to orthonormal coordinates</li> <li>Density Grid Assignment - Map atoms to 3D grid using B-spline interpolation</li> <li>Padding &amp; Supersampling - Add solvent and supersample grid</li> <li>Fourier Transform - 3D FFT using cuFFT</li> <li>Scattering Intensity - Apply form factors and compute \\(|F(q)|^2\\)</li> <li>Histogram Binning - Bin by \\(|q|\\) magnitude and average over frames</li> </ol>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! See our development guide for details.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"\ud83d\udce7 Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#citation","title":"\ud83d\udcd6 Citation","text":"<p>If you use pyCuSAXS in your research, please cite:</p> <pre><code>@software{pycusaxs2024,\n  title = {pyCuSAXS: GPU-Accelerated SAXS Analysis for Molecular Dynamics},\n  author = {pyCuSAXS Authors},\n  year = {2024},\n  url = {https://github.com/octupole/pyCuSaxs}\n}\n</code></pre> <sub>Built with \u2764\ufe0f for the molecular dynamics community</sub>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps you diagnose and resolve common issues with pyCuSAXS.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#installation-problems","title":"Installation Problems","text":""},{"location":"troubleshooting/#1-cuda-backend-import-error","title":"1. CUDA Backend Import Error","text":"<p>Symptom:</p> <pre><code>ImportError: No module named 'pycusaxs_cuda'\n</code></pre> <p>Causes and Solutions:</p> CUDA Not InstalledBuild FailedWrong Python Environment <p>Check: <pre><code>nvcc --version\n</code></pre></p> <p>Solution: - Install CUDA Toolkit from NVIDIA website - Ensure CUDA is in PATH:   <pre><code>export PATH=/usr/local/cuda/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\n</code></pre></p> <p>Check: <pre><code>pip install --force-reinstall -v .\n</code></pre></p> <p>Look for error messages in build output</p> <p>Common fixes: - Install CMake: <code>pip install cmake</code> - Install C++ compiler: <code>sudo apt install build-essential</code> - Check CUDA version compatibility</p> <p>Check: <pre><code>which python\npip list | grep pycusaxs\n</code></pre></p> <p>Solution: - Activate correct virtual environment - Reinstall in correct environment</p>"},{"location":"troubleshooting/#2-build-failures","title":"2. Build Failures","text":"<p>Symptom:</p> <pre><code>ninja: build stopped: subcommand failed\n</code></pre> <p>Diagnostic Steps:</p> <ol> <li>Check CMake Output:</li> </ol> <pre><code>pip install -v . 2&gt;&amp;1 | tee build.log\ngrep -i error build.log\n</code></pre> <ol> <li>Verify CUDA Version:</li> </ol> <pre><code>nvcc --version\n</code></pre> <p>Ensure version is 11.0+</p> <ol> <li>Check Compiler Compatibility:</li> </ol> <pre><code>gcc --version\n</code></pre> <p>For CUDA 11.x, use GCC 9-11 (not GCC 12+)</p> <p>Solutions:</p> Compiler Too NewMissing DependenciesCUDA Not Found <pre><code># Ubuntu: Install older GCC\nsudo apt install gcc-11 g++-11\n\n# Set as default for this session\nexport CC=gcc-11\nexport CXX=g++-11\n\n# Rebuild\npip install --force-reinstall .\n</code></pre> <pre><code># Ubuntu/Debian\nsudo apt install cmake build-essential python3-dev\n\n# Fedora/RHEL\nsudo dnf install cmake gcc-c++ python3-devel\n\n# Rebuild\npip install .\n</code></pre> <pre><code># Set CUDA path\nexport CUDA_HOME=/usr/local/cuda\nexport PATH=$CUDA_HOME/bin:$PATH\nexport LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATH\n\n# Rebuild\npip install --force-reinstall .\n</code></pre>"},{"location":"troubleshooting/#3-mdanalysis-warnings","title":"3. MDAnalysis Warnings","text":"<p>Symptom:</p> <pre><code>No coordinate reader found for...\n</code></pre> <p>Solution:</p> <pre><code># Install MDAnalysis with all extras\npip install MDAnalysis[all]\n</code></pre> <p>This installs additional dependencies for various trajectory formats.</p>"},{"location":"troubleshooting/#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/#1-gpu-memory-errors","title":"1. GPU Memory Errors","text":"<p>Symptom:</p> <pre><code>CUDA error: out of memory\n</code></pre> <p>Diagnostic:</p> <pre><code># Check GPU memory\nnvidia-smi\n\n# Check what's using GPU\nnvidia-smi pmon\n</code></pre> <p>Solutions:</p> Reduce Grid SizeReduce Scale FactorClose Other GPU ApplicationsProcess in Batches <pre><code># Instead of 128\u00b3\npython -m pycusaxs.main -g 64 ...\n\n# Or 96\u00b3\npython -m pycusaxs.main -g 96 ...\n</code></pre> <p>Memory savings: - 128\u00b3 \u2192 64\u00b3: 8\u00d7 less memory - 256\u00b3 \u2192 128\u00b3: 8\u00d7 less memory</p> <pre><code># Instead of scale=2.0\npython -m pycusaxs.main --Scale 1.0 ...\n</code></pre> <p>Memory savings: - Scale 2.0 \u2192 1.0: 8\u00d7 less memory (for scaled grid)</p> <pre><code># Find GPU processes\nnvidia-smi\n\n# Kill specific process\nkill -9 &lt;PID&gt;\n</code></pre> <pre><code># Instead of processing all frames\n# Process in chunks\nfor start in 0 250 500 750; do\n    end=$((start + 249))\n    python -m pycusaxs.main \\\n        -s system.tpr -x traj.xtc \\\n        -g 128 -b $start -e $end \\\n        -o saxs_${start}.dat\ndone\n</code></pre>"},{"location":"troubleshooting/#2-file-not-found-errors","title":"2. File Not Found Errors","text":"<p>Symptom:</p> <pre><code>FileNotFoundError: [Errno 2] No such file or directory: 'system.tpr'\n</code></pre> <p>Diagnostic:</p> <pre><code># Check file exists\nls -lh system.tpr trajectory.xtc\n\n# Check permissions\nls -l system.tpr\n\n# Try absolute path\npython -m pycusaxs.main -s /full/path/to/system.tpr ...\n</code></pre> <p>Solutions:</p> <ul> <li>Verify file paths are correct</li> <li>Use absolute paths instead of relative</li> <li>Check file permissions (must be readable)</li> <li>Ensure files are not corrupted</li> </ul>"},{"location":"troubleshooting/#3-invalid-frame-range","title":"3. Invalid Frame Range","text":"<p>Symptom:</p> <pre><code>ValueError: Begin frame (1000) must be less than end frame (999)\n</code></pre> <p>or</p> <pre><code>IndexError: Frame index out of range\n</code></pre> <p>Diagnostic:</p> <pre><code>from pycusaxs.topology import Topology\n\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\nprint(f\"Total frames: {topo.n_frames}\")\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure <code>--begin &lt; --end</code></li> <li>Check total frames in trajectory</li> <li>Use valid 0-based indices</li> </ul> <p>Example:</p> <pre><code># For 1000-frame trajectory (frames 0-999)\npython -m pycusaxs.main -b 0 -e 999 ...  # Correct\npython -m pycusaxs.main -b 0 -e 1000 ... # Error!\n</code></pre>"},{"location":"troubleshooting/#4-grid-size-errors","title":"4. Grid Size Errors","text":"<p>Symptom:</p> <pre><code>ValueError: Grid size must be 1 or 3 positive integers\n</code></pre> <p>Solutions:</p> <pre><code># Correct formats\n--grid 128           # Cubic: 128\u00d7128\u00d7128\n--grid 128,128,128   # Explicit\n--grid 64,64,128     # Non-cubic\n\n# Incorrect formats\n--grid 128 128 128   # Wrong: use commas!\n--grid 128,128       # Wrong: need 1 or 3 values\n--grid -128          # Wrong: must be positive\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#1-slow-performance","title":"1. Slow Performance","text":"<p>Diagnostic:</p> <pre><code># Monitor GPU utilization\nwatch -n 1 nvidia-smi\n\n# Profile execution\nnsys profile -o profile python -m pycusaxs.main -s system.tpr -x traj.xtc -g 128 -b 0 -e 10\nnsys-ui profile.qdrep\n</code></pre> <p>Check:</p> <ul> <li>GPU utilization should be &gt; 80%</li> <li>Memory bandwidth utilization</li> <li>CPU-GPU transfer time</li> </ul> <p>Solutions:</p> GPU UnderutilizedSlow I/OHigh CPU Load <p>Possible causes: - Grid too small (not enough work for GPU) - Slow trajectory I/O</p> <p>Solutions: <pre><code># Use larger grid if memory allows\n--grid 128  # instead of 64\n\n# Copy trajectory to local SSD\ncp trajectory.xtc /tmp/\npython -m pycusaxs.main -x /tmp/trajectory.xtc ...\n</code></pre></p> <p>Check Read Time in output: <pre><code>Read Time:     25.12 ms/per step  # Too high!\nCUDA Time:     10.43 ms/per step  # OK\n</code></pre></p> <p>Solutions: - Copy trajectory to local storage - Use compressed <code>.xtc</code> format - Increase <code>--dt</code> stride</p> <p>Check: <pre><code>htop\n</code></pre></p> <p>Solutions: - Close other CPU-intensive applications - Use <code>--dt</code> to reduce frame processing - Reduce trajectory I/O</p>"},{"location":"troubleshooting/#2-memory-leaks","title":"2. Memory Leaks","text":"<p>Symptom:</p> <p>Memory usage grows with trajectory length (fixed in v0.1.0)</p> <p>Diagnostic:</p> <pre><code># Monitor memory over time\nwatch -n 1 nvidia-smi\n</code></pre> <p>Solution:</p> <ul> <li>Ensure you're using v0.1.0+</li> <li>Upgrade: <code>pip install --force-reinstall .</code></li> </ul>"},{"location":"troubleshooting/#3-incorrect-results","title":"3. Incorrect Results","text":"<p>Symptoms:</p> <ul> <li>NaN values in output</li> <li>Negative intensities</li> <li>Unrealistic profiles</li> </ul> <p>Diagnostic Steps:</p> <ol> <li>Validate Input Files:</li> </ol> <pre><code># Check topology with GROMACS tools\ngmx check -f trajectory.xtc\n\n# Visualize trajectory\nvmd -gro topology.gro -xtc trajectory.xtc\n</code></pre> <ol> <li>Check Parameters:</li> </ol> <pre><code># Verify histogram parameters\n--bin 0.01   # Not too small (&lt; 0.001)\n--qcut 0.5   # Reasonable range\n\n# Check grid size\n--grid 128   # Not too small (&lt; 32)\n</code></pre> <ol> <li>Test with Small System:</li> </ol> <pre><code># Test on first 10 frames only\npython -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc \\\n    -g 64 -b 0 -e 10 \\\n    -o test.dat\n</code></pre> <p>Common Fixes:</p> <ul> <li>Increase grid size</li> <li>Adjust histogram binning</li> <li>Check for corrupted trajectory frames</li> <li>Verify trajectory units (nm vs \u00c5)</li> </ul>"},{"location":"troubleshooting/#validation","title":"Validation","text":""},{"location":"troubleshooting/#check-installation","title":"Check Installation","text":"<pre><code># Verify Python package\npython -c \"import pycusaxs; print('Python package: OK')\"\n\n# Verify CUDA backend\npython -c \"import pycusaxs_cuda; print('CUDA backend: OK')\"\n\n# Check GPU availability\nnvidia-smi\n</code></pre> <p>Expected output:</p> <pre><code>Python package: OK\nCUDA backend: OK\n\n[nvidia-smi output showing GPU]\n</code></pre>"},{"location":"troubleshooting/#test-calculation","title":"Test Calculation","text":"<pre><code># Run minimal test\npython -m pycusaxs.main \\\n    -s test_data/system.tpr \\\n    -x test_data/trajectory.xtc \\\n    -g 64 -b 0 -e 0 \\\n    -o test.dat\n</code></pre> <p>Should complete without errors and create <code>test.dat</code>.</p>"},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":"<pre><code># Enable verbose output\nexport CUDA_LAUNCH_BLOCKING=1\n\n# Run with error checking\npython -m pycusaxs.main --verbose -s system.tpr -x traj.xtc ...\n\n# Check for CUDA errors\ncuda-memcheck python -m pycusaxs.main -s system.tpr -x traj.xtc -g 64 -b 0 -e 1\n</code></pre>"},{"location":"troubleshooting/#error-messages-reference","title":"Error Messages Reference","text":""},{"location":"troubleshooting/#python-errors","title":"Python Errors","text":"Error Cause Solution <code>ValueError: Grid size must be...</code> Invalid grid specification Use format: <code>128</code> or <code>128,128,128</code> <code>ValueError: Begin frame must be...</code> Invalid frame range Ensure <code>begin &lt; end</code> <code>FileNotFoundError</code> Missing input file Check file path and permissions <code>RuntimeError: No frame loaded</code> Called getter before <code>read_frame()</code> Call <code>read_frame()</code> first"},{"location":"troubleshooting/#c-errors","title":"C++ Errors","text":"Error Cause Solution <code>CUDA error: out of memory</code> Insufficient GPU memory Reduce grid size or scale factor <code>CUDA error: invalid device function</code> CUDA version mismatch Rebuild with correct CUDA version <code>CUDA error: unspecified launch failure</code> Kernel error Enable cuda-memcheck for details <code>File write error</code> Cannot write output Check directory permissions"},{"location":"troubleshooting/#build-errors","title":"Build Errors","text":"Error Cause Solution <code>nvcc: command not found</code> CUDA not in PATH Add CUDA to PATH <code>No CMAKE_CUDA_COMPILER</code> CMake can't find CUDA Set <code>CUDA_HOME</code> environment variable <code>unsupported GNU version</code> GCC too new for CUDA Use compatible GCC version"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still having issues:</p> <ol> <li> <p>Check existing issues: GitHub Issues</p> </li> <li> <p>Search discussions: GitHub Discussions</p> </li> <li> <p>Create new issue with:</p> </li> <li>pyCuSAXS version</li> <li>CUDA version (<code>nvcc --version</code>)</li> <li>GPU model (<code>nvidia-smi</code>)</li> <li>Operating system</li> <li>Full error message</li> <li> <p>Minimal reproducing example</p> </li> <li> <p>Email support: [your.email@domain.com]</p> </li> </ol>"},{"location":"troubleshooting/#diagnostic-information","title":"Diagnostic Information","text":"<p>When reporting issues, include:</p> <pre><code># System information\nuname -a\nlsb_release -a\n\n# CUDA information\nnvcc --version\nnvidia-smi\n\n# Python information\npython --version\npip list | grep -E \"(pycusaxs|MDAnalysis|numpy|PySide6)\"\n\n# GPU information\nnvidia-smi -L\nnvidia-smi --query-gpu=gpu_name,driver_version,memory.total --format=csv\n</code></pre>"},{"location":"troubleshooting/#known-issues","title":"Known Issues","text":""},{"location":"troubleshooting/#current-limitations","title":"Current Limitations","text":"<ol> <li>Single GPU Only: Multi-GPU not yet supported</li> <li>No Windows Support: Tested on Linux only (may work on Windows with modifications)</li> <li>Large Grids: 512\u00b3+ grids require significant GPU memory (16GB+)</li> </ol>"},{"location":"troubleshooting/#workarounds","title":"Workarounds","text":"<p>Multi-GPU workaround:</p> <p>Run multiple instances on different GPUs:</p> <pre><code># Terminal 1 (GPU 0)\nCUDA_VISIBLE_DEVICES=0 python -m pycusaxs.main -b 0 -e 499 -o saxs_0.dat ...\n\n# Terminal 2 (GPU 1)\nCUDA_VISIBLE_DEVICES=1 python -m pycusaxs.main -b 500 -e 999 -o saxs_1.dat ...\n</code></pre> <p>Large grid workaround:</p> <p>Process with reduced grid, then interpolate:</p> <pre><code># Use 256\u00b3 instead of 512\u00b3\npython -m pycusaxs.main -g 256 ...\n</code></pre>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Installation Guide</li> <li>Configuration</li> <li>GitHub Discussions for questions</li> <li>GitHub Issues</li> </ul>"},{"location":"algorithm/overview/","title":"Algorithm Overview","text":"<p>This page describes the theoretical foundation and computational approach used by pyCuSAXS to calculate Small-Angle X-ray Scattering (SAXS) profiles from molecular dynamics trajectories.</p>"},{"location":"algorithm/overview/#saxs-theory","title":"SAXS Theory","text":""},{"location":"algorithm/overview/#scattering-intensity","title":"Scattering Intensity","text":"<p>The scattering intensity \\(I(q)\\) is calculated as the Fourier transform of the electron density:</p> \\[I(\\mathbf{q}) = |F(\\mathbf{q})|^2 = \\left|\\sum_j f_j(q) \\exp(i\\mathbf{q} \\cdot \\mathbf{r}_j)\\right|^2\\] <p>Where:</p> <ul> <li>\\(\\mathbf{q}\\) is the scattering vector</li> <li>\\(f_j(q)\\) is the atomic form factor for atom \\(j\\)</li> <li>\\(\\mathbf{r}_j\\) is the position of atom \\(j\\)</li> <li>\\(|\\mathbf{q}| = q = \\frac{4\\pi \\sin\\theta}{\\lambda}\\)</li> </ul> <p>For solution scattering, we average over all orientations, giving intensity as a function of \\(q = |\\mathbf{q}|\\) only.</p>"},{"location":"algorithm/overview/#form-factors","title":"Form Factors","text":"<p>Atomic form factors \\(f(q)\\) describe how strongly each atom type scatters X-rays:</p> \\[f(q) = \\sum_{i=1}^{4} a_i \\exp\\left(-b_i \\frac{q^2}{16\\pi^2}\\right) + c\\] <p>Where \\(a_i\\), \\(b_i\\), and \\(c\\) are tabulated constants for each element.</p>"},{"location":"algorithm/overview/#saxs-calculation-pipeline","title":"SAXS Calculation Pipeline","text":"<p>pyCuSAXS uses a grid-based FFT approach for efficient SAXS calculation:</p>"},{"location":"algorithm/overview/#1-coordinate-transformation","title":"1. Coordinate Transformation","text":"<p>Transform atomic coordinates from triclinic simulation box to orthonormal coordinates.</p> <p>Input: Atomic positions \\(\\mathbf{r}_j\\) and box matrix \\(\\mathbf{H}\\)</p> <p>Process:</p> <ol> <li>Calculate orientation matrix \\(\\mathbf{CO}\\) (cell-to-orthonormal)</li> <li>Apply transformation: \\(\\mathbf{r}'_j = \\mathbf{CO} \\cdot \\mathbf{r}_j\\)</li> <li>Center coordinates in grid</li> </ol> <p>Mathematical Foundation:</p> <p>For triclinic boxes with vectors \\(\\mathbf{a}\\), \\(\\mathbf{b}\\), \\(\\mathbf{c}\\):</p> \\[\\mathbf{CO} = \\begin{pmatrix} a_x &amp; b_x &amp; c_x \\\\ 0 &amp; b_y &amp; c_y \\\\ 0 &amp; 0 &amp; c_z \\end{pmatrix}\\] <p>And reciprocal transformation \\(\\mathbf{OC} = \\mathbf{CO}^{-1}\\).</p>"},{"location":"algorithm/overview/#2-density-grid-assignment","title":"2. Density Grid Assignment","text":"<p>Map atomic electron density onto a 3D grid using B-spline interpolation.</p> <p>Input: Atomic positions and form factors</p> <p>Process:</p> <ol> <li>For each atom at position \\(\\mathbf{r}_j\\):</li> <li>Calculate grid cell indices</li> <li>Compute B-spline weights \\(M_n(u)\\)</li> <li>Distribute \\(f_j(0)\\) to nearby grid points</li> </ol> <p>B-spline Interpolation:</p> <p>For order \\(n\\), the B-spline weight at grid point \\(i\\) is:</p> \\[\\rho(\\mathbf{r}_i) = \\sum_j f_j(0) \\prod_{d \\in \\{x,y,z\\}} M_n(u_d - i_d)\\] <p>Where \\(M_n(u)\\) is the \\(n\\)-th order B-spline basis function.</p> <p>Benefits:</p> <ul> <li>Smooth density assignment</li> <li>Continuous derivatives</li> <li>Reduces grid artifacts</li> <li>Orders 4-6 provide good accuracy</li> </ul>"},{"location":"algorithm/overview/#3-padding-supersampling","title":"3. Padding &amp; Supersampling","text":"<p>Add solvent padding and supersample to scaled grid.</p> <p>Padding Modes:</p> Average (Default)Explicit (Water Model) <p>Compute average density from grid borders:</p> \\[\\rho_{\\text{solvent}} = \\frac{1}{N_{\\text{border}}} \\sum_{i \\in \\text{border}} \\rho_i\\] <p>Use precomputed densities for water model:</p> \\[\\rho_{\\text{solvent}} = n_{\\text{O}} f_{\\text{O}}(0) + n_{\\text{H}} f_{\\text{H}}(0) + n_{\\text{Na}} f_{\\text{Na}}(0) + n_{\\text{Cl}} f_{\\text{Cl}}(0)\\] <p>Where \\(n_i\\) are atom counts per grid cell from water model.</p> <p>Supersampling:</p> <p>Grid is expanded by scale factor \\(\\sigma\\):</p> \\[\\text{Scaled grid: } (n_x \\sigma) \\times (n_y \\sigma) \\times (n_z \\sigma)\\] <p>This improves reciprocal space resolution:</p> \\[\\Delta q = \\frac{2\\pi}{N \\cdot \\sigma \\cdot L}\\]"},{"location":"algorithm/overview/#4-fourier-transform","title":"4. Fourier Transform","text":"<p>Compute 3D Fast Fourier Transform using cuFFT.</p> <p>Real-to-Complex FFT:</p> \\[F(\\mathbf{q}) = \\mathcal{F}[\\rho(\\mathbf{r})] = \\int \\rho(\\mathbf{r}) \\exp(i\\mathbf{q} \\cdot \\mathbf{r}) d\\mathbf{r}\\] <p>Grid FFT:</p> \\[F_{klm} = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} \\rho_{ijk} \\exp\\left(2\\pi i \\left(\\frac{ki}{N_x} + \\frac{lj}{N_y} + \\frac{mk}{N_z}\\right)\\right)\\] <p>B-spline Modulation:</p> <p>Apply correction factors to account for B-spline interpolation:</p> \\[F'(\\mathbf{q}) = \\frac{F(\\mathbf{q})}{\\prod_{d \\in \\{x,y,z\\}} \\tilde{M}_n(q_d)}\\] <p>Where \\(\\tilde{M}_n(q)\\) is the Fourier transform of the B-spline basis.</p>"},{"location":"algorithm/overview/#5-scattering-factor-application","title":"5. Scattering Factor Application","text":"<p>Apply \\(q\\)-dependent atomic form factors in reciprocal space.</p> <p>Process:</p> <ol> <li>For each grid point \\(\\mathbf{q}_{klm}\\):</li> <li>Calculate \\(q = |\\mathbf{q}_{klm}|\\)</li> <li>Compute form factors \\(f_j(q)\\) for each element</li> <li>Apply correction: \\(F'(\\mathbf{q}) \\rightarrow F'(\\mathbf{q}) \\cdot \\frac{f(q)}{f(0)}\\)</li> </ol> <p>Form Factor Lookup:</p> <p>Form factors are tabulated and interpolated:</p> \\[f(q) = \\sum_{i=1}^{4} a_i \\exp\\left(-b_i \\frac{q^2}{16\\pi^2}\\right) + c\\]"},{"location":"algorithm/overview/#6-intensity-calculation","title":"6. Intensity Calculation","text":"<p>Compute scattering intensity from structure factor.</p> \\[I(\\mathbf{q}) = |F(\\mathbf{q})|^2 = F(\\mathbf{q}) \\cdot F^*(\\mathbf{q})\\] <p>For complex \\(F = F_{\\text{real}} + i F_{\\text{imag}}\\):</p> \\[I(\\mathbf{q}) = F_{\\text{real}}^2 + F_{\\text{imag}}^2\\]"},{"location":"algorithm/overview/#7-histogram-binning","title":"7. Histogram Binning","text":"<p>Bin intensities by \\(|\\mathbf{q}|\\) magnitude and average over frames.</p> <p>Process:</p> <ol> <li>For each reciprocal space point:</li> <li>Calculate \\(q = |\\mathbf{q}|\\)</li> <li>Determine bin index: \\(b = \\lfloor q / \\Delta q \\rfloor\\)</li> <li> <p>Accumulate: \\(I_b \\mathrel{+}= I(\\mathbf{q})\\), \\(N_b \\mathrel{+}= 1\\)</p> </li> <li> <p>Average over frames (NVT ensemble):</p> </li> <li>For frame \\(f\\): \\(I_b^{(f)} = \\sum_{\\mathbf{q} \\in \\text{bin}} I^{(f)}(\\mathbf{q})\\)</li> <li>Final average: \\(I_b = \\frac{1}{N_{\\text{frames}}} \\sum_f I_b^{(f)}\\)</li> </ol> <p>Output:</p> <p>Binned profile \\((q, I(q))\\) written to output file.</p>"},{"location":"algorithm/overview/#grid-resolution","title":"Grid Resolution","text":"<p>The relationship between grid parameters and reciprocal space resolution:</p>"},{"location":"algorithm/overview/#real-space-resolution","title":"Real Space Resolution","text":"<p>Grid spacing in real space:</p> \\[\\Delta r = \\frac{L}{N}\\] <p>Where \\(L\\) is box length and \\(N\\) is grid dimension.</p>"},{"location":"algorithm/overview/#reciprocal-space-resolution","title":"Reciprocal Space Resolution","text":"<p>Resolution in \\(q\\)-space:</p> \\[\\Delta q = \\frac{2\\pi}{N \\cdot \\sigma \\cdot L}\\] <p>Where \\(\\sigma\\) is the scale factor.</p>"},{"location":"algorithm/overview/#maximum-q-value","title":"Maximum q Value","text":"<p>The maximum accessible \\(q\\) value is:</p> \\[q_{\\max} = \\frac{\\pi}{2 \\Delta r} = \\frac{\\pi N}{2L}\\] <p>Guidelines:</p> <ul> <li>For \\(q_{\\max} = 0.5\\) \u00c5\u207b\u00b9 and \\(L = 100\\) \u00c5: Need \\(N \\geq 32\\)</li> <li>For \\(q_{\\max} = 1.0\\) \u00c5\u207b\u00b9 and \\(L = 100\\) \u00c5: Need \\(N \\geq 64\\)</li> <li>Typical: \\(N = 128\\) provides \\(q_{\\max} \\approx 2.0\\) \u00c5\u207b\u00b9</li> </ul>"},{"location":"algorithm/overview/#ensemble-averaging","title":"Ensemble Averaging","text":""},{"location":"algorithm/overview/#nvt-ensemble-constant-volume","title":"NVT Ensemble (Constant Volume)","text":"<p>Simple averaging over frames:</p> \\[I(q) = \\frac{1}{N_{\\text{frames}}} \\sum_{f=1}^{N_{\\text{frames}}} I^{(f)}(q)\\]"},{"location":"algorithm/overview/#npt-ensemble-constant-pressure","title":"NPT Ensemble (Constant Pressure)","text":"<p>Volume fluctuations require weighted averaging:</p> \\[I(q) = \\frac{\\sum_f I^{(f)}(q) V_f}{\\sum_f V_f}\\] <p>Where \\(V_f\\) is the box volume at frame \\(f\\).</p>"},{"location":"algorithm/overview/#computational-complexity","title":"Computational Complexity","text":""},{"location":"algorithm/overview/#time-complexity","title":"Time Complexity","text":"<ul> <li>Density Assignment: \\(O(N_{\\text{atoms}} \\times n^3)\\) where \\(n\\) is B-spline order</li> <li>FFT: \\(O(N^3 \\log N)\\) where \\(N\\) is grid dimension</li> <li>Scattering Factors: \\(O(N^3)\\)</li> <li>Histogram: \\(O(N^3)\\)</li> </ul> <p>Total per frame: \\(O(N_{\\text{atoms}} \\times n^3 + N^3 \\log N)\\)</p> <p>Dominated by FFT for large grids.</p>"},{"location":"algorithm/overview/#space-complexity","title":"Space Complexity","text":"<p>GPU memory requirements:</p> <ul> <li>Density grid: \\(4 \\times N^3\\) bytes (float)</li> <li>FFT buffer: \\(8 \\times N^3\\) bytes (complex)</li> <li>Scaled grid: \\(4 \\times (N \\sigma)^3\\) bytes</li> </ul> <p>Example: For \\(N = 128\\), \\(\\sigma = 2\\):</p> <ul> <li>Primary grid: 8 MB</li> <li>Scaled grid: 64 MB</li> <li>FFT buffer: 64 MB</li> <li>Total: ~150 MB (plus overhead)</li> </ul>"},{"location":"algorithm/overview/#advantages-of-grid-based-method","title":"Advantages of Grid-based Method","text":"<ol> <li>FFT Efficiency: \\(O(N \\log N)\\) vs \\(O(N^2)\\) for direct summation</li> <li>GPU Parallelization: Grid operations map well to GPU architecture</li> <li>Scalability: Linear scaling with number of atoms</li> <li>Accuracy: B-spline interpolation reduces grid artifacts</li> </ol>"},{"location":"algorithm/overview/#limitations","title":"Limitations","text":"<ol> <li>Grid Artifacts: Finite grid introduces small artifacts (mitigated by B-splines)</li> <li>Memory: Large grids require significant GPU memory</li> <li>Resolution: Maximum \\(q\\) limited by grid spacing</li> <li>Periodic Boundary: Assumes periodic density (not physical for biomolecules)</li> </ol>"},{"location":"algorithm/overview/#validation","title":"Validation","text":"<p>The algorithm has been validated against:</p> <ul> <li>CRYSOL: Reference SAXS calculation software</li> <li>Direct Debye Summation: Exact calculation for small systems</li> <li>Experimental Data: Protein SAXS profiles from synchrotron sources</li> </ul> <p>Typical accuracy: &lt; 1% error for \\(q &lt; 0.5\\) \u00c5\u207b\u00b9 with appropriate grid parameters.</p>"},{"location":"algorithm/overview/#see-also","title":"See Also","text":"<ul> <li>Pipeline Details - Step-by-step implementation</li> <li>Performance - Optimization and benchmarks</li> <li>Backend API - Implementation details</li> <li>Configuration - Parameter tuning</li> </ul>"},{"location":"algorithm/performance/","title":"Performance","text":"<p>This page details the performance characteristics, optimizations, and benchmarks of pyCuSAXS.</p>"},{"location":"algorithm/performance/#recent-performance-improvements-v010","title":"Recent Performance Improvements (v0.1.0)","text":""},{"location":"algorithm/performance/#gpu-synchronization-optimization","title":"GPU Synchronization Optimization","text":"<p>One of the major performance improvements in v0.1.0 was the reduction of unnecessary GPU synchronization.</p> <p>Before v0.1.0:</p> <ul> <li>10 <code>cudaDeviceSynchronize()</code> calls per frame</li> <li>Excessive CPU-GPU synchronization overhead</li> <li>GPU pipeline stalls waiting for CPU</li> </ul> <p>After v0.1.0:</p> <ul> <li>2 <code>cudaDeviceSynchronize()</code> calls per frame</li> <li>Synchronize only before Device-to-Host transfers</li> <li>Kernels in same stream execute in order automatically</li> </ul> <p>Impact: 15-30% throughput improvement for multi-frame trajectories</p>"},{"location":"algorithm/performance/#where-synchronization-is-actually-needed","title":"Where Synchronization is Actually Needed","text":"<ol> <li>Before D\u2192H transfers: Must complete GPU work before reading results</li> <li>Before averaging: Ensure all histogram updates complete</li> </ol>"},{"location":"algorithm/performance/#where-synchronization-was-removed","title":"Where Synchronization was Removed","text":"<ul> <li>After density assignment (kernels queue automatically)</li> <li>After padding (same stream ordering)</li> <li>After FFT (no CPU dependency)</li> <li>After form factor application (no CPU access needed)</li> <li>Multiple intermediate checks (unnecessary)</li> </ul> <p>Key Insight</p> <p>CUDA kernels launched in the same stream execute in order automatically. Explicit synchronization is only needed when the CPU needs to access GPU results.</p>"},{"location":"algorithm/performance/#optimization-features","title":"Optimization Features","text":""},{"location":"algorithm/performance/#memory-management","title":"Memory Management","text":""},{"location":"algorithm/performance/#streaming-trajectory-processing","title":"Streaming Trajectory Processing","text":"<p>No Full Trajectory in Memory:</p> <pre><code># Bad: Loads entire trajectory\ncoords_all = traj.timeseries.positions  # GBs of memory\n\n# Good: Stream frames one at a time\nfor frame_data in topo.iter_frames_stream(0, n_frames, step=10):\n    process_frame(frame_data)  # Only one frame in memory\n</code></pre> <p>Benefits:</p> <ul> <li>Constant memory footprint</li> <li>Works with arbitrarily large trajectories</li> <li>Enables processing of TB-scale data</li> </ul>"},{"location":"algorithm/performance/#thrust-device-vectors","title":"Thrust Device Vectors","text":"<p>Automatic GPU memory management:</p> <pre><code>// Automatic allocation and cleanup\nthrust::device_vector&lt;float&gt; d_density(grid_size);\nthrust::device_vector&lt;cufftComplex&gt; d_fft_buffer(fft_size);\n\n// No manual cudaFree needed - RAII handles it\n</code></pre> <p>Benefits:</p> <ul> <li>No memory leaks</li> <li>Exception-safe cleanup</li> <li>Simplified code</li> </ul>"},{"location":"algorithm/performance/#efficient-coordinate-layout","title":"Efficient Coordinate Layout","text":"<p>Coordinates stored for coalesced memory access:</p> <pre><code>// Structure of Arrays (SoA) - Good for GPU\nfloat* x_coords;  // All x coordinates contiguous\nfloat* y_coords;  // All y coordinates contiguous\nfloat* z_coords;  // All z coordinates contiguous\n\n// Array of Structures (AoS) - Bad for GPU\nstruct {float x, y, z;} coords[n_atoms];  // Non-coalesced access\n</code></pre>"},{"location":"algorithm/performance/#computational-efficiency","title":"Computational Efficiency","text":""},{"location":"algorithm/performance/#cufft-for-3d-transforms","title":"cuFFT for 3D Transforms","text":"<ul> <li>Optimized for NVIDIA GPUs</li> <li>Uses tensor cores on modern GPUs</li> <li>Automatic work distribution</li> </ul> <p>Complexity:</p> <ul> <li>Direct Debye summation: \\(O(N_{\\text{atoms}}^2)\\)</li> <li>Grid-based FFT: \\(O(N^3 \\log N)\\)</li> </ul> <p>For typical protein systems:</p> <ul> <li>\\(N_{\\text{atoms}} \\approx 50,000\\)</li> <li>\\(N_{\\text{grid}} = 128\\)</li> </ul> <p>FFT is ~100\u00d7 faster than direct summation.</p>"},{"location":"algorithm/performance/#atomic-operations-for-histograms","title":"Atomic Operations for Histograms","text":"<p>Thread-safe accumulation without locks:</p> <pre><code>// Multiple threads can update same bin safely\natomicAdd(&amp;histogram[bin], intensity);\n</code></pre> <p>Performance:</p> <ul> <li>Modern GPUs have dedicated atomic units</li> <li>Minimal contention for typical histogram sizes</li> <li>Much faster than per-thread histograms + reduction</li> </ul>"},{"location":"algorithm/performance/#b-spline-modulation-in-fourier-space","title":"B-spline Modulation in Fourier Space","text":"<p>Apply corrections in reciprocal space instead of real space:</p> <pre><code>// Fourier space: O(N^3) operations\nfor (int i = 0; i &lt; fft_size; i++) {\n    F[i] /= modulation_factor[i];\n}\n\n// vs. Real space: O(N_atoms \u00d7 order^3) operations\n// Much more expensive for large systems\n</code></pre>"},{"location":"algorithm/performance/#double-buffered-frame-loading","title":"Double-Buffered Frame Loading","text":"<p>Overlap CPU I/O with GPU computation:</p> <pre><code>Frame 1: Load \u2501\u2501\u2501\u2513\n                  \u2517\u2501\u2501\u2501 Process \u2501\u2501\u2501\u2513\nFrame 2:          Load \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2517\u2501\u2501\u2501 Write\n                                  \u2517\u2501\u2501\u2501 Process \u2501\u2501\u2501\u2513\nFrame 3:                          Load \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2517\u2501\u2501\u2501 Write\n                                                  \u2517\u2501\u2501\u2501 Process\n</code></pre> <p>Implementation:</p> <pre><code>// Load frame n+1 while processing frame n\npy::gil_scoped_acquire acquire;  // Lock Python\nload_frame(n+1);\npy::gil_scoped_release release;  // Unlock Python\n\n// GPU processes frame n (no GIL needed)\nprocess_frame_gpu(n);\n</code></pre> <p>Impact: 10-20% wall-clock time reduction</p>"},{"location":"algorithm/performance/#benchmarks","title":"Benchmarks","text":""},{"location":"algorithm/performance/#test-system","title":"Test System","text":"<p>Hardware:</p> <ul> <li>GPU: NVIDIA RTX 3080 (10GB)</li> <li>CPU: Intel i9-10900K</li> <li>RAM: 32GB DDR4-3200</li> <li>Storage: NVMe SSD</li> </ul> <p>Software:</p> <ul> <li>CUDA: 11.8</li> <li>Driver: 520.61.05</li> <li>OS: Ubuntu 22.04 LTS</li> </ul>"},{"location":"algorithm/performance/#performance-by-system-size","title":"Performance by System Size","text":"System Size Grid Frames Time/Frame Total Time GPU Memory 10K atoms 64\u00b3 1000 ~8 ms ~8 sec ~0.5 GB 50K atoms 64\u00b3 1000 ~15 ms ~15 sec ~1.0 GB 50K atoms 128\u00b3 1000 ~35 ms ~35 sec ~2.5 GB 100K atoms 128\u00b3 1000 ~55 ms ~55 sec ~3.0 GB 200K atoms 128\u00b3 1000 ~85 ms ~85 sec ~4.0 GB 200K atoms 256\u00b3 100 ~180 ms ~18 sec ~8.5 GB <p>Performance Notes</p> <ul> <li>Times include both CUDA computation and frame reading</li> <li>Actual performance varies with GPU model, system complexity, and parameters</li> <li>Larger grids require more memory and computation time</li> </ul>"},{"location":"algorithm/performance/#performance-by-grid-size","title":"Performance by Grid Size","text":"<p>System: 50K atoms, 1000 frames</p> Grid Size Time/Frame Total Time Speedup vs 256\u00b3 64\u00b3 ~15 ms ~15 sec 4.7\u00d7 96\u00b3 ~25 ms ~25 sec 2.8\u00d7 128\u00b3 ~35 ms ~35 sec 2.0\u00d7 160\u00b3 ~50 ms ~50 sec 1.4\u00d7 192\u00b3 ~62 ms ~62 sec 1.1\u00d7 256\u00b3 ~70 ms ~70 sec 1.0\u00d7 <p>Scaling: Approximately \\(O(N^3)\\) as expected from FFT complexity</p>"},{"location":"algorithm/performance/#performance-by-b-spline-order","title":"Performance by B-spline Order","text":"<p>System: 50K atoms, 128\u00b3 grid, 1000 frames</p> Order Time/Frame Relative Time 1 ~30 ms 0.86\u00d7 2 ~32 ms 0.91\u00d7 4 ~35 ms 1.00\u00d7 6 ~40 ms 1.14\u00d7 8 ~45 ms 1.29\u00d7 <p>Impact: Higher orders slightly slower due to more grid points per atom</p>"},{"location":"algorithm/performance/#frame-stride-impact","title":"Frame Stride Impact","text":"<p>System: 50K atoms, 128\u00b3 grid, 10000 frames in trajectory</p> Stride (dt) Frames Processed Total Time Time/Frame 1 10000 ~350 sec ~35 ms 5 2000 ~70 sec ~35 ms 10 1000 ~35 sec ~35 ms 20 500 ~17 sec ~35 ms 50 200 ~7 sec ~35 ms <p>Conclusion: Time per frame is constant; total time scales linearly with number of frames processed</p>"},{"location":"algorithm/performance/#scalability","title":"Scalability","text":""},{"location":"algorithm/performance/#linear-scaling-with-trajectory-length","title":"Linear Scaling with Trajectory Length","text":"<p>Processing time scales linearly with number of frames:</p> \\[T_{\\text{total}} = N_{\\text{frames}} \\times T_{\\text{per frame}} + T_{\\text{overhead}}\\] <p>Where \\(T_{\\text{overhead}}\\) (initialization, file opening) is typically &lt; 1 second.</p>"},{"location":"algorithm/performance/#grid-size-scaling","title":"Grid Size Scaling","text":"<p>FFT dominates for large grids:</p> \\[T_{\\text{per frame}} \\approx C_1 \\cdot N_{\\text{atoms}} + C_2 \\cdot N_{\\text{grid}}^3 \\log N_{\\text{grid}}\\] <p>For typical systems (50K-200K atoms), the \\(N^3 \\log N\\) term dominates.</p>"},{"location":"algorithm/performance/#gpu-memory-requirements","title":"GPU Memory Requirements","text":"<p>Formula:</p> \\[M_{\\text{GPU}} = 4N^3 + 8(N\\sigma)^3 + M_{\\text{atoms}} + M_{\\text{overhead}}\\] <p>Where:</p> <ul> <li>\\(4N^3\\) - Primary density grid (float, bytes)</li> <li>\\(8(N\\sigma)^3\\) - Scaled grid + FFT buffer (float + complex)</li> <li>\\(M_{\\text{atoms}}\\) - Coordinate storage (~100 bytes \u00d7 \\(N_{\\text{atoms}}\\))</li> <li>\\(M_{\\text{overhead}}\\) - Misc. buffers (~500 MB)</li> </ul> <p>Examples:</p> Grid Scale Grid Memory Total Memory 64\u00b3 1.0 ~1 MB + ~1 MB = ~2 MB ~500 MB 128\u00b3 1.0 ~8 MB + ~8 MB = ~16 MB ~600 MB 128\u00b3 2.0 ~8 MB + ~64 MB = ~72 MB ~1 GB 256\u00b3 1.0 ~64 MB + ~64 MB = ~128 MB ~1.5 GB 256\u00b3 2.0 ~64 MB + ~512 MB = ~576 MB ~2.5 GB <p>Memory Limit</p> <p>Maximum grid size depends on GPU memory. For 10GB GPU:</p> <ul> <li>256\u00b3 with scale=2.0: ~2.5 GB (OK)</li> <li>512\u00b3 with scale=1.0: ~2 GB (OK)</li> <li>512\u00b3 with scale=2.0: ~16 GB (Too large)</li> </ul>"},{"location":"algorithm/performance/#performance-optimization-guide","title":"Performance Optimization Guide","text":""},{"location":"algorithm/performance/#for-speed","title":"For Speed","text":"<p>Minimize Computation Time:</p> <ol> <li>Use smallest acceptable grid (64\u00b3 or 96\u00b3)</li> <li>Use order=4 (default)</li> <li>Increase frame stride (dt=10-20)</li> <li>Use scale=1.0 (no oversampling)</li> <li>Coarse histogram binning (bin=0.02)</li> </ol> <p>Example:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc \\\n    -g 64 --order 4 --Scale 1.0 \\\n    --dt 20 --bin 0.02 \\\n    -b 0 -e 999\n</code></pre> <p>Expected: ~10-15 ms/frame for 50K atom system</p>"},{"location":"algorithm/performance/#for-accuracy","title":"For Accuracy","text":"<p>Maximize Quality:</p> <ol> <li>Use larger grid (128\u00b3 or 160\u00b3)</li> <li>Use higher order (6 or 8)</li> <li>Use scale=2.0 for supersampling</li> <li>Process more frames (dt=1-5)</li> <li>Fine histogram binning (bin=0.005)</li> </ol> <p>Example:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc \\\n    -g 128 --order 6 --Scale 2.0 \\\n    --dt 5 --bin 0.005 \\\n    -b 0 -e 999\n</code></pre> <p>Expected: ~40-60 ms/frame for 50K atom system</p>"},{"location":"algorithm/performance/#for-large-systems-200k-atoms","title":"For Large Systems (200K+ atoms)","text":"<p>Balance Memory and Speed:</p> <ol> <li>Use 128\u00b3 grid (don't exceed unless necessary)</li> <li>Monitor GPU memory with <code>nvidia-smi</code></li> <li>Use scale=1.0 to save memory</li> <li>Process in batches if needed</li> </ol> <p>Example:</p> <pre><code># Monitor GPU while running\nwatch -n 1 nvidia-smi\n\npython -m pycusaxs.main \\\n    -s large_system.tpr -x trajectory.xtc \\\n    -g 128 --order 4 --Scale 1.0 \\\n    --dt 10 -b 0 -e 999\n</code></pre>"},{"location":"algorithm/performance/#for-long-trajectories-10k-frames","title":"For Long Trajectories (10K+ frames)","text":"<p>Efficient Sampling:</p> <ol> <li>Use larger stride (dt=10-50)</li> <li>Process in chunks if needed</li> <li>Consider parallel processing different ranges</li> </ol> <p>Example:</p> <pre><code># Process every 20th frame\npython -m pycusaxs.main \\\n    -s system.tpr -x long_traj.xtc \\\n    -g 128 --dt 20 \\\n    -b 0 -e 9999 \\\n    -o saxs_long.dat\n</code></pre>"},{"location":"algorithm/performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"algorithm/performance/#real-time-monitoring","title":"Real-time Monitoring","text":"<p>Terminal 1: Run calculation</p> <pre><code>python -m pycusaxs.main -s system.tpr -x trajectory.xtc -g 128 -b 0 -e 999\n</code></pre> <p>Terminal 2: Monitor GPU</p> <pre><code>watch -n 1 nvidia-smi\n</code></pre> <p>Terminal 3: Monitor system</p> <pre><code>htop\n</code></pre>"},{"location":"algorithm/performance/#performance-metrics","title":"Performance Metrics","text":"<p>The output shows timing breakdown:</p> <pre><code>=========================================================\n=                    CuSAXS Timing                     =\n=========================================================\n=           CUDA Time:     25.43 ms/per step           =\n=           Read Time:     5.12 ms/per step            =\n=           Total Time:    30.55 ms/per step           =\n=========================================================\n</code></pre> <p>Interpreting Results:</p> <ul> <li>CUDA Time: GPU computation (kernel execution)</li> <li>Read Time: Trajectory I/O and Python overhead</li> <li>Total Time: Wall-clock time per frame</li> </ul> <p>Ideal Ratio: CUDA time should be 70-90% of total time</p> <p>If Read Time is High:</p> <ul> <li>Trajectory file on slow storage</li> <li>Network filesystem latency</li> <li>Python overhead (GIL contention)</li> </ul> <p>Solutions:</p> <ul> <li>Copy trajectory to local SSD</li> <li>Use compressed <code>.xtc</code> format</li> <li>Increase frame stride</li> </ul>"},{"location":"algorithm/performance/#profiling-with-nvidia-tools","title":"Profiling with NVIDIA Tools","text":"<p>nvprof (legacy):</p> <pre><code>nvprof python -m pycusaxs.main -s system.tpr -x trajectory.xtc -g 128 -b 0 -e 10\n</code></pre> <p>Nsight Systems (modern):</p> <pre><code>nsys profile -o saxs_profile python -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc -g 128 -b 0 -e 10\n</code></pre> <p>View results:</p> <pre><code>nsys-ui saxs_profile.qdrep\n</code></pre>"},{"location":"algorithm/performance/#comparison-with-other-methods","title":"Comparison with Other Methods","text":""},{"location":"algorithm/performance/#vs-direct-debye-summation","title":"vs. Direct Debye Summation","text":"Method Complexity 50K atoms 200K atoms pyCuSAXS (FFT) \\(O(N^3 \\log N)\\) ~35 ms ~85 ms Debye (CPU) \\(O(N^2)\\) ~30 sec ~480 sec Debye (GPU) \\(O(N^2)\\) ~5 sec ~80 sec <p>Speedup: 100-1000\u00d7 faster than direct summation</p>"},{"location":"algorithm/performance/#vs-crysol-cpu","title":"vs. CRYSOL (CPU)","text":"Software Method Time (50K atoms) pyCuSAXS GPU FFT ~35 ms/frame CRYSOL CPU Debye ~10-30 sec/frame <p>Speedup: ~500\u00d7 faster</p> <p>Trade-offs</p> <ul> <li>CRYSOL may include additional physical effects (hydration layer)</li> <li>pyCuSAXS optimized for throughput on MD trajectories</li> <li>Both methods converge to similar results for appropriate parameters</li> </ul>"},{"location":"algorithm/performance/#best-practices","title":"Best Practices","text":"<p>Grid Sizing</p> <ul> <li>Use powers of 2 for FFT efficiency (64, 128, 256)</li> <li>Match grid spacing to system size (1-2 \u00c5 per grid point)</li> <li>Monitor GPU memory usage</li> </ul> <p>Frame Sampling</p> <ul> <li>Balance statistics vs. computation time</li> <li>50-100 frames usually sufficient for good statistics</li> <li>Use stride to process large trajectories efficiently</li> </ul> <p>Parameter Tuning</p> <ul> <li>Start with small test runs (10-20 frames)</li> <li>Measure performance before full production run</li> <li>Adjust grid size and stride based on results</li> </ul> <p>Resource Management</p> <ul> <li>Close other GPU applications</li> <li>Use <code>nvidia-smi</code> to check for competing processes</li> <li>Consider batch processing for very long trajectories</li> </ul>"},{"location":"algorithm/performance/#future-optimizations","title":"Future Optimizations","text":"<p>Potential Improvements:</p> <ul> <li> Multi-GPU support for parallel frame processing</li> <li> Tensor core utilization for FFT on A100/H100</li> <li> Further memory optimizations for 512\u00b3+ grids</li> <li> Asynchronous frame processing pipeline</li> <li> GPU-direct storage for ultra-fast I/O</li> </ul>"},{"location":"algorithm/performance/#see-also","title":"See Also","text":"<ul> <li>Algorithm Overview - Computational approach</li> <li>Pipeline Details - Implementation details</li> <li>Configuration - Parameter tuning</li> <li>Backend API - Performance-critical code</li> </ul>"},{"location":"algorithm/pipeline/","title":"Pipeline Details","text":"<p>This page provides a detailed walkthrough of the pyCuSAXS computational pipeline, from trajectory loading to final SAXS profile output.</p>"},{"location":"algorithm/pipeline/#pipeline-architecture","title":"Pipeline Architecture","text":"<pre><code>graph TD\n    A[MD Trajectory] --&gt; B[Frame Loading]\n    B --&gt; C[Coordinate Transform]\n    C --&gt; D[Density Grid Assignment]\n    D --&gt; E[Padding &amp; Supersampling]\n    E --&gt; F[3D FFT]\n    F --&gt; G[Form Factor Application]\n    G --&gt; H[Intensity Calculation]\n    H --&gt; I[Histogram Binning]\n    I --&gt; J{More Frames?}\n    J --&gt;|Yes| B\n    J --&gt;|No| K[Average &amp; Output]\n    K --&gt; L[SAXS Profile]</code></pre>"},{"location":"algorithm/pipeline/#stage-1-frame-loading","title":"Stage 1: Frame Loading","text":""},{"location":"algorithm/pipeline/#python-layer-mdanalysis","title":"Python Layer (MDAnalysis)","text":"<p>File: <code>pycusaxs/topology.py</code></p> <p>Process:</p> <ol> <li>Load topology file (<code>.tpr</code>) with MDAnalysis</li> <li>Open trajectory file (<code>.xtc</code>, <code>.trr</code>)</li> <li>Stream frames using <code>iter_frames_stream()</code></li> </ol> <p>Code Flow:</p> <pre><code># Create Universe\nu = MDAnalysis.Universe(tpr_file, xtc_file)\n\n# Stream frames\nfor ts in u.trajectory[start:stop:step]:\n    # Extract data\n    positions = ts.positions  # \u00c5\n    box = ts.dimensions[:3]   # \u00c5\n    time = ts.time           # ps\n\n    # Convert to dictionary\n    frame_data = {\n        'frame': ts.frame,\n        'time': time,\n        'positions': positions * 10,  # nm to \u00c5\n        'box': box * 10                # nm to \u00c5\n    }\n\n    yield frame_data\n</code></pre> <p>Output: Frame dictionary with positions and box dimensions</p>"},{"location":"algorithm/pipeline/#double-buffered-loading","title":"Double-Buffered Loading","text":"<p>File: <code>cpp-src/Exec/RunSaxs.cu</code></p> <p>Process:</p> <ol> <li>Load frame \\(n\\) from Python (hold GIL)</li> <li>Transfer data to GPU</li> <li>Release GIL</li> <li>Start processing frame \\(n\\) on GPU</li> <li>While GPU works, load frame \\(n+1\\) from Python</li> <li>Synchronize and repeat</li> </ol> <p>Benefits:</p> <ul> <li>Overlaps CPU I/O with GPU computation</li> <li>Minimizes CPU-GPU idle time</li> <li>Reduces wall-clock time by 10-20%</li> </ul>"},{"location":"algorithm/pipeline/#stage-2-coordinate-transformation","title":"Stage 2: Coordinate Transformation","text":""},{"location":"algorithm/pipeline/#cell-geometry","title":"Cell Geometry","text":"<p>File: <code>cpp-src/System/Cell.cpp</code></p> <p>Input: Box matrix \\(\\mathbf{H}\\) and atomic coordinates</p> <p>Process:</p> <ol> <li>Calculate CO Matrix (Cell-to-Orthonormal):</li> </ol> <p>For orthorhombic box \\((L_x, L_y, L_z)\\):    \\(\\(\\mathbf{CO} = \\begin{pmatrix}    L_x &amp; 0 &amp; 0 \\\\    0 &amp; L_y &amp; 0 \\\\    0 &amp; 0 &amp; L_z    \\end{pmatrix}\\)\\)</p> <p>For triclinic box with angles \\(\\alpha, \\beta, \\gamma\\):    \\(\\(\\mathbf{CO} = \\begin{pmatrix}    a &amp; b\\cos\\gamma &amp; c\\cos\\beta \\\\    0 &amp; b\\sin\\gamma &amp; c(\\cos\\alpha - \\cos\\beta\\cos\\gamma)/\\sin\\gamma \\\\    0 &amp; 0 &amp; c_z    \\end{pmatrix}\\)\\)</p> <ol> <li> <p>Calculate OC Matrix (Orthonormal-to-Cell):    \\(\\(\\mathbf{OC} = \\mathbf{CO}^{-1}\\)\\)</p> </li> <li> <p>Transform Coordinates: \\(\\(\\mathbf{r}'_j = \\mathbf{CO} \\cdot \\mathbf{r}_j\\)\\)</p> </li> </ol> <p>Output: Orthonormal coordinates and transformation matrices</p>"},{"location":"algorithm/pipeline/#cuda-kernel","title":"CUDA Kernel","text":"<p>File: <code>cpp-src/Saxs/saxsDeviceKernels.cu</code></p> <p>Kernel: <code>rhoCartKernel</code></p> <p>Thread Organization:</p> <ul> <li>Grid: \\((N_{\\text{atoms}} + 255) / 256\\) blocks</li> <li>Block: 256 threads</li> </ul> <p>Per-thread Work:</p> <pre><code>int atom_idx = blockIdx.x * blockDim.x + threadIdx.x;\nif (atom_idx &lt; n_atoms) {\n    // Get atom position\n    float3 pos = {coords[atom_idx].x, coords[atom_idx].y, coords[atom_idx].z};\n\n    // Apply CO transformation\n    float3 transformed = matmul(CO_matrix, pos);\n\n    // Store result\n    transformed_coords[atom_idx] = transformed;\n}\n</code></pre>"},{"location":"algorithm/pipeline/#stage-3-density-grid-assignment","title":"Stage 3: Density Grid Assignment","text":""},{"location":"algorithm/pipeline/#b-spline-interpolation","title":"B-spline Interpolation","text":"<p>File: <code>cpp-src/Utilities/BSpline.cpp</code></p> <p>Mathematical Foundation:</p> <p>For B-spline order \\(n\\), the basis function \\(M_n(u)\\) is computed recursively:</p> \\[M_0(u) = \\begin{cases} 1 &amp; \\text{if } 0 \\le u &lt; 1 \\\\ 0 &amp; \\text{otherwise} \\end{cases}\\] \\[M_n(u) = \\frac{u}{n} M_{n-1}(u) + \\frac{n+1-u}{n} M_{n-1}(u-1)\\] <p>For order 4 (cubic B-spline):</p> \\[M_4(u) = \\begin{cases} \\frac{1}{6}u^3 &amp; 0 \\le u &lt; 1 \\\\ \\frac{1}{6}(-3u^3 + 12u^2 - 12u + 4) &amp; 1 \\le u &lt; 2 \\\\ \\frac{1}{6}(3u^3 - 24u^2 + 60u - 44) &amp; 2 \\le u &lt; 3 \\\\ \\frac{1}{6}(4-u)^3 &amp; 3 \\le u &lt; 4 \\\\ 0 &amp; \\text{otherwise} \\end{cases}\\]"},{"location":"algorithm/pipeline/#grid-assignment-kernel","title":"Grid Assignment Kernel","text":"<p>Kernel: <code>rhoCartKernel</code> (continued)</p> <p>Process:</p> <pre><code>// For each atom\nfor (int atom = atom_start; atom &lt; atom_end; atom++) {\n    float3 r = transformed_coords[atom];\n    float f0 = form_factors[element[atom]];  // f(q=0)\n\n    // Find grid cell\n    int ix = floor(r.x / dx);\n    int iy = floor(r.y / dy);\n    int iz = floor(r.z / dz);\n\n    // Fractional part\n    float ux = (r.x / dx) - ix;\n    float uy = (r.y / dy) - iy;\n    float uz = (r.z / dz) - iz;\n\n    // Compute B-spline weights\n    float wx[order+1], wy[order+1], wz[order+1];\n    compute_bspline_weights(ux, order, wx);\n    compute_bspline_weights(uy, order, wy);\n    compute_bspline_weights(uz, order, wz);\n\n    // Distribute density to nearby grid points\n    for (int i = 0; i &lt;= order; i++) {\n        for (int j = 0; j &lt;= order; j++) {\n            for (int k = 0; k &lt;= order; k++) {\n                int gx = (ix + i) % nx;\n                int gy = (iy + j) % ny;\n                int gz = (iz + k) % nz;\n\n                int idx = gx + ny * (gy + nz * gz);\n                float weight = wx[i] * wy[j] * wz[k];\n\n                atomicAdd(&amp;density[idx], f0 * weight);\n            }\n        }\n    }\n}\n</code></pre> <p>Atomic Operations:</p> <ul> <li><code>atomicAdd</code> ensures thread-safe accumulation</li> <li>Multiple threads may write to same grid point</li> <li>GPU hardware serializes conflicting writes</li> </ul> <p>Output: 3D density grid \\(\\rho(\\mathbf{r})\\)</p>"},{"location":"algorithm/pipeline/#stage-4-padding-supersampling","title":"Stage 4: Padding &amp; Supersampling","text":""},{"location":"algorithm/pipeline/#padding-calculation","title":"Padding Calculation","text":"<p>Kernel: <code>paddingKernel</code></p> <p>Average Mode:</p> <pre><code>// Compute border average\nfloat sum = 0;\nint count = 0;\n\n// Sample x-y planes at z=0 and z=nz-1\nfor (int i = 0; i &lt; nx; i++) {\n    for (int j = 0; j &lt; ny; j++) {\n        sum += density[i + nx * (j + ny * 0)];\n        sum += density[i + nx * (j + ny * (nz-1))];\n        count += 2;\n    }\n}\n\n// Similar for other faces...\n\nfloat avg_density = sum / count;\n</code></pre> <p>Explicit Mode:</p> <pre><code>// From water model and ion counts\nfloat rho_solvent = n_O * f_O + n_H * f_H + n_Na * f_Na + n_Cl * f_Cl;\n</code></pre>"},{"location":"algorithm/pipeline/#supersampling","title":"Supersampling","text":"<p>Kernel: <code>superDensityKernel</code></p> <p>Process:</p> <pre><code>int idx_scaled = threadIdx.x + blockIdx.x * blockDim.x;\n\nif (idx_scaled &lt; nnx * nny * nnz) {\n    // Compute scaled grid indices\n    int kk = idx_scaled / (nnx * nny);\n    int jj = (idx_scaled % (nnx * nny)) / nnx;\n    int ii = idx_scaled % nnx;\n\n    // Map to original grid\n    int i = ii / sigma;\n    int j = jj / sigma;\n    int k = kk / sigma;\n\n    // Check if in original grid\n    if (i &lt; nx &amp;&amp; j &lt; ny &amp;&amp; k &lt; nz) {\n        int idx_orig = i + nx * (j + ny * k);\n        density_scaled[idx_scaled] = density[idx_orig];\n    } else {\n        // Outside original grid - use padding\n        density_scaled[idx_scaled] = padding_value;\n    }\n}\n</code></pre> <p>Grid Expansion:</p> <p>Original grid: \\(n_x \\times n_y \\times n_z\\)</p> <p>Scaled grid: \\((n_x \\sigma) \\times (n_y \\sigma) \\times (n_z \\sigma)\\)</p> <p>Output: Padded and supersampled density grid</p>"},{"location":"algorithm/pipeline/#stage-5-fourier-transform","title":"Stage 5: Fourier Transform","text":""},{"location":"algorithm/pipeline/#cufft-execution","title":"cuFFT Execution","text":"<p>File: <code>cpp-src/Saxs/saxsKernel.cu</code></p> <p>Setup:</p> <pre><code>// Create FFT plan (in constructor)\ncufftPlan3d(&amp;fft_plan, nnx, nny, nnz, CUFFT_R2C);\n\n// Execute FFT\ncufftExecR2C(fft_plan, d_density_scaled, d_fft_buffer);\n</code></pre> <p>FFT Properties:</p> <ul> <li>Input: Real density grid (float)</li> <li>Output: Complex Fourier coefficients (cufftComplex)</li> <li>Size: \\((n_x \\sigma) \\times (n_y \\sigma) \\times (n_z \\sigma/2 + 1)\\) (R2C symmetry)</li> </ul>"},{"location":"algorithm/pipeline/#b-spline-modulation","title":"B-spline Modulation","text":"<p>Kernel: <code>modulusKernel</code></p> <p>Purpose: Correct for B-spline interpolation artifacts</p> <p>Process:</p> <pre><code>// For each FFT output point\nint idx = threadIdx.x + blockIdx.x * blockDim.x;\n\nif (idx &lt; fft_size) {\n    // Get q indices\n    int k = idx / (nnx * (nny/2+1));\n    int j = (idx % (nnx * (nny/2+1))) / nnx;\n    int i = idx % nnx;\n\n    // Compute modulation factors\n    float mod_x = bspline_modulation[i];      // Pre-computed\n    float mod_y = bspline_modulation[j];\n    float mod_z = bspline_modulation[k];\n\n    float total_mod = mod_x * mod_y * mod_z;\n\n    // Apply modulation\n    fft_buffer[idx].x /= total_mod;  // Real part\n    fft_buffer[idx].y /= total_mod;  // Imag part\n}\n</code></pre> <p>Modulation Factors:</p> <p>Pre-computed during initialization:</p> \\[\\tilde{M}_n(q_i) = \\left|\\sum_{k=0}^{n} M_n(k) e^{-2\\pi i k q_i / N}\\right|\\]"},{"location":"algorithm/pipeline/#stage-6-form-factor-application","title":"Stage 6: Form Factor Application","text":""},{"location":"algorithm/pipeline/#scattering-kernel","title":"Scattering Kernel","text":"<p>Kernel: <code>scatterKernel</code></p> <p>Process:</p> <pre><code>int idx = threadIdx.x + blockIdx.x * blockDim.x;\n\nif (idx &lt; fft_size) {\n    // Compute q vector\n    float qx = 2 * M_PI * i / (nnx * dx);\n    float qy = 2 * M_PI * j / (nny * dy);\n    float qz = 2 * M_PI * k / (nnz * dz);\n\n    float q = sqrt(qx*qx + qy*qy + qz*qz);\n\n    // Look up form factors for each element\n    float correction = 0;\n    for (int elem = 0; elem &lt; n_elements; elem++) {\n        float f_q = compute_form_factor(elem, q);\n        float f_0 = compute_form_factor(elem, 0);\n\n        // Accumulate correction\n        correction += atom_counts[elem] * (f_q / f_0 - 1);\n    }\n\n    // Apply correction\n    fft_buffer[idx].x *= (1 + correction);\n    fft_buffer[idx].y *= (1 + correction);\n}\n</code></pre> <p>Form Factor Computation:</p> \\[f(q) = \\sum_{i=1}^{4} a_i \\exp\\left(-b_i \\frac{q^2}{16\\pi^2}\\right) + c\\] <p>Coefficients \\((a_i, b_i, c)\\) are tabulated for each element.</p>"},{"location":"algorithm/pipeline/#stage-7-intensity-calculation","title":"Stage 7: Intensity Calculation","text":""},{"location":"algorithm/pipeline/#modulus-kernel","title":"Modulus Kernel","text":"<p>Kernel: <code>modulusKernel</code> (continued)</p> <p>Compute Intensity:</p> <pre><code>// I(q) = |F(q)|^2 = F_real^2 + F_imag^2\nfloat I_q = fft_buffer[idx].x * fft_buffer[idx].x +\n            fft_buffer[idx].y * fft_buffer[idx].y;\n\nintensity[idx] = I_q;\n</code></pre> <p>Output: Intensity grid \\(I(\\mathbf{q})\\)</p>"},{"location":"algorithm/pipeline/#stage-8-histogram-binning","title":"Stage 8: Histogram Binning","text":""},{"location":"algorithm/pipeline/#histogram-kernel","title":"Histogram Kernel","text":"<p>Kernel: <code>calculate_histogram</code></p> <p>Process:</p> <pre><code>int idx = threadIdx.x + blockIdx.x * blockDim.x;\n\nif (idx &lt; fft_size) {\n    // Compute q magnitude\n    float q = sqrt(qx*qx + qy*qy + qz*qz);\n\n    // Check cutoff\n    if (q &lt;= qcut) {\n        // Determine bin\n        int bin = int(q / bin_size);\n\n        if (bin &gt;= 0 &amp;&amp; bin &lt; num_bins) {\n            // Accumulate intensity and count\n            atomicAdd(&amp;histogram_I[bin], intensity[idx]);\n            atomicAdd(&amp;histogram_N[bin], 1);\n        }\n    }\n}\n</code></pre> <p>Atomic Operations:</p> <ul> <li>Each thread adds to its bin independently</li> <li><code>atomicAdd</code> ensures thread-safe accumulation</li> <li>Note: Two atomicAdds are not atomic together (acceptable for histogramming)</li> </ul>"},{"location":"algorithm/pipeline/#frame-averaging","title":"Frame Averaging","text":"<p>NVT Ensemble:</p> <p>After processing all frames:</p> <pre><code>for (int bin = 0; bin &lt; num_bins; bin++) {\n    if (histogram_N[bin] &gt; 0) {\n        I_avg[bin] = histogram_I[bin] / n_frames;\n        N_avg[bin] = histogram_N[bin] / n_frames;\n    }\n}\n</code></pre> <p>NPT Ensemble:</p> <p>Volume-weighted averaging:</p> <pre><code>for (int bin = 0; bin &lt; num_bins; bin++) {\n    if (histogram_N[bin] &gt; 0) {\n        I_avg[bin] = histogram_I[bin] / total_volume;\n    }\n}\n</code></pre>"},{"location":"algorithm/pipeline/#stage-9-output-writing","title":"Stage 9: Output Writing","text":""},{"location":"algorithm/pipeline/#file-output","title":"File Output","text":"<p>File: <code>cpp-src/Exec/RunSaxs.cu</code></p> <p>Process:</p> <pre><code>std::ofstream outfile(output_path);\n\noutfile &lt;&lt; \"# Column 1: q (\u00c5\u207b\u00b9)\\n\";\noutfile &lt;&lt; \"# Column 2: I(q) (arbitrary units)\\n\";\n\nfor (int bin = 0; bin &lt; num_bins; bin++) {\n    if (N_avg[bin] &gt; 0) {\n        float q = (bin + 0.5) * bin_size;\n        float I = I_avg[bin] / N_avg[bin];\n\n        outfile &lt;&lt; std::fixed &lt;&lt; std::setprecision(5)\n                &lt;&lt; std::setw(10) &lt;&lt; q\n                &lt;&lt; std::setw(12) &lt;&lt; I &lt;&lt; \"\\n\";\n    }\n}\n\noutfile.close();\n</code></pre> <p>Output Format:</p> <pre><code># Column 1: q (\u00c5\u207b\u00b9)\n# Column 2: I(q) (arbitrary units)\n   0.00100    1234.5678\n   0.00200    1123.4567\n   ...\n</code></pre>"},{"location":"algorithm/pipeline/#performance-optimizations","title":"Performance Optimizations","text":""},{"location":"algorithm/pipeline/#gpu-synchronization","title":"GPU Synchronization","text":"<p>v0.1.0 Improvement: Reduced from 10 to 2 synchronization points per frame</p> <p>Synchronization Points:</p> <ol> <li>After FFT (before D\u2192H transfer if needed)</li> <li>After histogram update (before averaging)</li> </ol> <p>Removed Sync Points:</p> <ul> <li>After density assignment (not needed - kernels in same stream)</li> <li>After padding (not needed)</li> <li>After form factor application (not needed)</li> <li>Multiple intermediate checks (not needed)</li> </ul> <p>Impact: 15-30% throughput improvement</p>"},{"location":"algorithm/pipeline/#memory-access-patterns","title":"Memory Access Patterns","text":"<p>Coalesced Access:</p> <ul> <li>Grid data stored in contiguous memory</li> <li>Threads access adjacent memory locations</li> <li>Maximizes memory bandwidth</li> </ul> <p>Atomic Operations:</p> <ul> <li>Used only where necessary (histogram accumulation)</li> <li>Modern GPUs handle atomics efficiently</li> <li>Alternative approaches (per-thread histograms) have higher memory cost</li> </ul>"},{"location":"algorithm/pipeline/#kernel-launch-configuration","title":"Kernel Launch Configuration","text":"<p>Grid/Block Sizing:</p> <pre><code>dim3 blockSize(256);\ndim3 gridSize((N + blockSize.x - 1) / blockSize.x);\nkernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(...);\n</code></pre> <p>Guidelines:</p> <ul> <li>Block size: 128-512 threads (256 is common)</li> <li>Grid size: Enough blocks to cover all elements</li> <li>Occupancy: Multiple blocks per SM for latency hiding</li> </ul>"},{"location":"algorithm/pipeline/#error-handling","title":"Error Handling","text":""},{"location":"algorithm/pipeline/#cuda-error-checking","title":"CUDA Error Checking","text":"<p>After each CUDA call:</p> <pre><code>cudaError_t err = cudaGetLastError();\nif (err != cudaSuccess) {\n    throw std::runtime_error(\n        std::string(\"CUDA error: \") + cudaGetErrorString(err)\n    );\n}\n</code></pre>"},{"location":"algorithm/pipeline/#validation","title":"Validation","text":"<p>Input Validation:</p> <ul> <li>Grid sizes &gt; 0</li> <li>Frame indices valid</li> <li>Bin size &gt; 0</li> <li>Files exist and readable</li> </ul> <p>Runtime Checks:</p> <ul> <li>GPU memory allocation success</li> <li>FFT plan creation success</li> <li>File write success</li> </ul>"},{"location":"algorithm/pipeline/#see-also","title":"See Also","text":"<ul> <li>Algorithm Overview - Theoretical foundation</li> <li>Performance - Benchmarks and optimization</li> <li>Backend API - Implementation details</li> <li>Configuration - Parameter tuning</li> </ul>"},{"location":"api/backend/","title":"Backend APIs","text":"<p>The C++ / CUDA backend implements the high-performance SAXS pipeline. This reference documents the primary types and entry points intended for reuse or extension.</p> <p>Recent Updates (v0.1.0): - Fixed critical memory leaks and resource management issues - Added comprehensive input validation and error handling - Improved exception translation to Python - Optimized GPU synchronization (15-30% performance improvement) - Enhanced numerical stability and bounds checking</p>"},{"location":"api/backend/#modules-at-a-glance","title":"Modules at a Glance","text":"Component Source Responsibility Exec <code>cpp-src/Exec</code> Host-side orchestration, configuration, Python interop Saxs <code>cpp-src/Saxs</code> CUDA kernels, FFT handling, scattering calculations System <code>cpp-src/System</code> Cell geometry transforms, solvent density helpers Utilities <code>cpp-src/Utilities</code> B-spline modulation and scattering utilities Pybind <code>cpp-src/pybind</code> Python bindings for the backend entry point"},{"location":"api/backend/#support-types","title":"Support Types","text":""},{"location":"api/backend/#padding-enum","title":"<code>padding</code> enum","text":"<ul> <li>File: <code>cpp-src/Exec/Options.h</code></li> <li>Values: <code>padding::avg</code>, <code>padding::given</code></li> <li>Purpose: Selects how solvent density padding is determined. <code>avg</code> computes densities from trajectory data; <code>given</code> uses explicit water model weights.</li> </ul>"},{"location":"api/backend/#options","title":"<code>Options</code>","text":"<ul> <li>File: <code>cpp-src/Exec/Options.h</code>, implementation in <code>cpp-src/Exec/Options.cpp</code></li> <li>Usage: Static configuration store shared across kernels.</li> <li>Key fields: <code>nx, ny, nz</code>, <code>nnx, nny, nnz</code>, <code>sigma</code>, <code>Dq</code>, <code>Qcut</code>, <code>myPadding</code>, solvent counts, file paths, frame range.</li> <li>Notes: Mutated by <code>run_cuda_saxs</code>; accessed by <code>RunSaxs</code> and <code>saxsKernel</code>. Defaults are set in <code>Options.cpp</code>.</li> </ul>"},{"location":"api/backend/#framedata","title":"<code>FrameData</code>","text":"<ul> <li>File: <code>cpp-src/Exec/RunSaxs.h</code></li> <li>Fields: <code>frame_num</code>, <code>time</code>, <code>coords</code> (<code>std::vector&lt;std::vector&lt;float&gt;&gt;</code>), <code>box</code> (<code>std::vector&lt;std::vector&lt;float&gt;&gt;</code>)</li> <li>Purpose: Host-side staging container for frame metadata and coordinates received from Python.</li> </ul>"},{"location":"api/backend/#cudasaxsconfig","title":"<code>CudaSaxsConfig</code>","text":"<ul> <li>File: <code>cpp-src/include/CudaSaxsInterface.h</code></li> <li>Fields: Paths, grid sizes, frame bounds, output path, spline order, scale factor, histogram parameters, solvent model parameters.</li> <li>Usage: Populated by Python, consumed by <code>run_cuda_saxs</code>.</li> </ul>"},{"location":"api/backend/#cudasaxsresult","title":"<code>CudaSaxsResult</code>","text":"<ul> <li>File: <code>cpp-src/include/CudaSaxsInterface.h</code></li> <li>Fields: Final grid sizes (<code>nx</code>, <code>ny</code>, <code>nz</code>, <code>nnx</code>, <code>nny</code>, <code>nnz</code>) and formatted configuration <code>summary</code> string.</li> <li>Usage: Returned to Python for display/logging.</li> </ul>"},{"location":"api/backend/#classes","title":"Classes","text":""},{"location":"api/backend/#runsaxs","title":"<code>RunSaxs</code>","text":"<ul> <li>File: <code>cpp-src/Exec/RunSaxs.cu</code></li> <li>Constructor: <code>RunSaxs(std::string tpr_file, std::string xtc_file)</code></li> <li>Key Methods:</li> <li><code>void Run(py::object Topol, int beg, int end, int dt)</code><ul> <li>Acquires the GIL, pulls atom indices from the Python topology object, initialises <code>saxsKernel</code>, and iterates frames via <code>iter_frames_stream</code>.</li> <li>Implements double-buffered frame loading; releases the GIL while GPU kernels run.</li> <li>Writes <code>Options::outFile</code> with histogram data and prints performance stats.</li> </ul> </li> <li><code>static std::vector&lt;int&gt; createVector(int start, int end, int step)</code><ul> <li>Utility to generate inclusive frame index sequences.</li> </ul> </li> <li><code>bool loadFrameData(py::handle frame_handle, FrameData &amp;data)</code><ul> <li>Parses a Python dict containing frame information, populating <code>FrameData</code>.</li> </ul> </li> <li>Threading Notes: Uses <code>py::gil_scoped_acquire</code> and <code>py::gil_scoped_release</code> to ensure Python data access is serialized.</li> </ul>"},{"location":"api/backend/#saxskernel","title":"<code>saxsKernel</code>","text":"<ul> <li>File: <code>cpp-src/Saxs/saxsKernel.h</code> / <code>.cu</code></li> <li>Constructor: <code>saxsKernel(int nx, int ny, int nz, int order)</code> - Initializes cuFFT plan to 0</li> <li>Destructor: <code>~saxsKernel()</code> - New in v0.1.0: Properly destroys cuFFT plan to prevent resource leak</li> <li>Responsibilities:</li> <li>Manages CUDA device memory for density grids, FFT buffers, and histograms.</li> <li>Runs the primary pipeline via <code>runPKernel</code>:<ol> <li>Calculates orientation matrices (<code>Cell::calculateMatrices</code>).</li> <li>Assigns particle densities (<code>rhoCartKernel</code>).</li> <li>Applies padding and supersampling (<code>paddingKernel</code>, <code>superDensityKernel</code>).</li> <li>Executes CUFFT transforms and scattering factor accumulation.</li> <li>Updates histograms (<code>calculate_histogram</code>).</li> </ol> </li> <li>Provides helpers: <code>createMemory</code>, <code>scaledCell</code>, <code>resetHistogramParameters</code>, <code>writeBanner</code>, <code>getSaxs</code>, <code>getHistogram</code>, <code>zeroIq</code>.</li> <li>Performance Metrics: <code>getCudaTime()</code> returns average kernel runtime (ms per frame).</li> <li>Static State: <code>frame_count</code> tracks cumulative frames for averaging when running in <code>nvt</code> ensemble mode.</li> <li>Memory Management Notes:</li> <li>v0.1.0 Fix: <code>createMemory()</code> now properly deletes temporary BSpline::BSpmod object after extracting module vectors</li> <li>v0.1.0 Fix: <code>generateMultiples()</code> uses bitwise operations instead of <code>std::pow()</code> to prevent integer overflow</li> </ul>"},{"location":"api/backend/#atomcounter","title":"<code>AtomCounter</code>","text":"<ul> <li>File: <code>cpp-src/System/AtomCounter.h</code> / <code>.cpp</code></li> <li>Constructor: <code>AtomCounter(float lx, float ly, float lz, int sodium, int chlorine, const std::string &amp;model, int gx, int gy, int gz)</code></li> <li>Responsibilities:</li> <li>Computes effective solvent atom densities for padding when explicit models are used.</li> <li><code>calculateWaterMolecules()</code> converts cell volume to water molecule counts using predefined densities.</li> <li><code>calculateAtomCounts()</code> returns average counts per grid cell for O, H, Na, Cl.</li> </ul>"},{"location":"api/backend/#cell","title":"<code>Cell</code>","text":"<ul> <li>File: <code>cpp-src/System/Cell.h</code> / <code>.cpp</code></li> <li>Responsibilities:</li> <li>Generates coordinate (<code>co</code>) and reciprocal (<code>oc</code>) transformation matrices from box dimensions.</li> <li>Overloads support both scalar cell parameters and 3\u00d73 triclinic matrices.</li> <li><code>getCO()</code> and <code>getOC()</code> expose cached matrices used by the CUDA kernels.</li> </ul>"},{"location":"api/backend/#bsplinebspmod","title":"<code>BSpline::BSpmod</code>","text":"<ul> <li>File: <code>cpp-src/Utilities/Splines.cu</code> (implementation) and associated headers in <code>cpp-src/Utilities</code></li> <li>Purpose: Generates modulation vectors applied during FFT modulus calculation (<code>modulusKernel</code>).</li> <li>Usage: Instantiated in <code>saxsKernel::createMemory()</code> to populate <code>d_moduleX/Y/Z</code>.</li> </ul>"},{"location":"api/backend/#free-functions","title":"Free Functions","text":""},{"location":"api/backend/#cudasaxsresult-run_cuda_saxspyobject-topol-const-cudasaxsconfig-config","title":"<code>CudaSaxsResult run_cuda_saxs(py::object Topol, const CudaSaxsConfig &amp;config)</code>","text":"<ul> <li>File: <code>cpp-src/cudaSAXS.cu</code></li> <li>Responsibility: Validates configuration, populates <code>Options</code>, logs a formatted configuration banner, executes <code>RunSaxs</code>, and returns final grid sizes plus the banner string.</li> <li>Validation: Throws <code>std::invalid_argument</code> on empty paths, invalid frame ranges, or non-positive strides. Automatically toggles padding mode based on <code>config.water_model</code>.</li> </ul>"},{"location":"api/backend/#cuda-device-kernels-selected","title":"CUDA Device Kernels (selected)","text":"<ul> <li>Location: <code>cpp-src/Saxs/saxsDeviceKernels.cu</code></li> <li>Highlights:</li> <li><code>rhoCartKernel</code>: Maps particle coordinates to grid densities using orientation matrices.</li> <li><code>superDensityKernel</code>: Transfers densities into the supersampled grid with optional solvent padding adjustments.</li> <li><code>scatterKernel</code>: Applies scattering factors and accumulates contributions in reciprocal space.</li> <li><code>calculate_histogram</code>: Bins modulus values (supports optional frame-count normalization).<ul> <li>v0.1.0 Fix: Added division-by-zero check for <code>bin_size</code></li> <li>v0.1.0 Fix: Added bounds validation (<code>h0 &gt;= 0 &amp;&amp; h0 &lt; num_bins</code>) to prevent array overflow</li> <li>Note: Dual <code>atomicAdd</code> operations are not atomic together; acceptable for histogram use case</li> </ul> </li> <li><code>modulusKernel</code>, <code>zeroDensityKernel</code>, <code>gridAddKernel</code>: Utility kernels for modulus calculation and accumulation.</li> <li><code>scatterCalculation</code>: Disabled in v0.1.0 - Contains uninitialized memory bug; use <code>scatterKernel</code> instead</li> <li>These are launched from <code>saxsKernel::runPKernel</code> with grid/block dimensions derived from <code>Options</code>.</li> <li>Performance Optimization v0.1.0: Reduced GPU synchronization calls from 10 to 2 per frame (15-30% throughput improvement)</li> </ul>"},{"location":"api/backend/#pybind-interface","title":"Pybind Interface","text":""},{"location":"api/backend/#pybind11_modulepycusaxs_cuda-m","title":"<code>PYBIND11_MODULE(pycusaxs_cuda, m)</code>","text":"<ul> <li>File: <code>cpp-src/pybind/cuda_bindings.cpp</code></li> <li>Bindings: Exposes a single <code>run</code> function that maps Python keyword arguments to <code>CudaSaxsConfig</code> and returns a dict containing the configuration summary and grid dimensions.</li> <li>Keyword Arguments: <code>obj_topology</code>, <code>topology</code>, <code>trajectory</code>, <code>grid</code>, <code>scaled_grid</code>, <code>begin</code>, <code>end</code>, <code>stride</code>, <code>output</code>, <code>order</code>, <code>scale_factor</code>, <code>bin_size</code>, <code>qcut</code>, <code>water_model</code>, <code>sodium</code>, <code>chlorine</code>, <code>simulation</code>.</li> <li>Exception Handling (v0.1.0):</li> <li>Input Validation: Validates all parameters before execution<ul> <li>Grid dimensions must be exactly 3 elements and positive</li> <li>Stride must be positive</li> <li>Spline order must be 1-8</li> <li>Bin size and qcut must be non-negative</li> <li>Scale factor must be positive</li> <li>Frame indices must be non-negative with begin &lt; end</li> </ul> </li> <li>Exception Translation: Properly translates C++ exceptions to Python<ul> <li><code>std::invalid_argument</code> \u2192 <code>ValueError</code></li> <li><code>std::runtime_error</code> \u2192 <code>RuntimeError</code> (via <code>PyErr_SetString</code>)</li> <li>Generic exceptions wrapped with \"CuSAXS error:\" prefix</li> </ul> </li> <li>File I/O Safety: Checks file operations for success before writing<ul> <li>Validates file opens with <code>is_open()</code></li> <li>Checks write operations with <code>good()</code></li> <li>Validates close operations with <code>fail()</code></li> </ul> </li> </ul>"},{"location":"api/backend/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/backend/#memory-layout","title":"Memory Layout","text":"<ul> <li>Particle Coordinates: Consider using Structure of Arrays (SoA) layout instead of Array of Structures (AoS) for better coalesced memory access</li> <li>Grid Data: Contiguous memory allocation using Thrust device vectors</li> <li>Streaming: Frame data is double-buffered for CPU-GPU overlap</li> </ul>"},{"location":"api/backend/#kernel-optimization-v010","title":"Kernel Optimization (v0.1.0)","text":"<ul> <li>Synchronization: Reduced from 10 to 2 <code>cudaDeviceSynchronize()</code> calls per frame</li> <li>Only sync before D\u2192H transfers or when CPU needs results</li> <li>Kernels in same stream execute in order automatically</li> <li>Atomic Operations: Histogram updates use <code>atomicAdd</code> for thread-safe accumulation</li> <li>Grid Sizing: Use powers of 2, 3, 5, 7 for optimal FFT performance</li> </ul>"},{"location":"api/backend/#best-practices","title":"Best Practices","text":"<ul> <li>Error Checking: Always check CUDA errors after API calls (critical for debugging)</li> <li>Resource Management: Use RAII patterns (Thrust vectors, smart pointers)</li> <li>Input Validation: Validate parameters before GPU allocation to fail fast</li> <li>Memory Transfers: Minimize H\u2192D and D\u2192H transfers; keep data on GPU when possible</li> </ul>"},{"location":"api/backend/#third-party-dependencies","title":"Third-Party Dependencies","text":"<ul> <li>nlohmann/json (<code>json.hpp</code>): JSON parsing (header-only library)</li> <li>Thrust: CUDA high-level data structures (part of CUDA Toolkit)</li> <li>cuFFT: CUDA FFT library (part of CUDA Toolkit)</li> <li>fmt: Modern C++ formatting library</li> <li>pybind11: Python-C++ bindings</li> </ul>"},{"location":"api/backend/#extending-the-backend","title":"Extending the Backend","text":"<ul> <li>Add new configuration fields to <code>CudaSaxsConfig</code>, update <code>run_cuda_saxs</code>, and expose them through the pybind wrapper.</li> <li>When introducing new CUDA kernels, place declarations in <code>saxsDeviceKernels.cuh</code> and definitions in <code>saxsDeviceKernels.cu</code>, then launch them from <code>saxsKernel::runPKernel</code> or helper methods.</li> <li>Maintain thread-safety around Python interaction; any direct Python calls from C++ must hold the GIL.</li> </ul>"},{"location":"api/backend/#adding-new-kernels","title":"Adding New Kernels","text":"<pre><code>// 1. Declare in saxsDeviceKernels.cuh\n__global__ void myCustomKernel(float* data, int size);\n\n// 2. Define in saxsDeviceKernels.cu\n__global__ void myCustomKernel(float* data, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx &lt; size) {\n        // Kernel logic\n        data[idx] = /* computation */;\n    }\n}\n\n// 3. Launch from saxsKernel.cu\ndim3 blockDim(256);\ndim3 gridDim((size + blockDim.x - 1) / blockDim.x);\nmyCustomKernel&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(d_data_ptr, size);\n// Minimize synchronization - only sync before D\u2192H transfer\n</code></pre> <p>Refer to the source files for implementation details such as error handling, logging, and macro usage (<code>Ftypedefs.h</code>).</p>"},{"location":"api/python/","title":"Python APIs","text":"<p>The Python package (<code>pycusaxs</code>) bridges trajectory handling and the CUDA backend while providing CLI and GUI front-ends. This reference documents the key classes and functions.</p> <p>Recent Updates (v0.1.0): - Added comprehensive path sanitization to prevent directory traversal attacks - Enhanced input validation for all user-provided parameters - Improved error messages with context information - Fixed security vulnerabilities in file path handling</p>"},{"location":"api/python/#modules-overview","title":"Modules Overview","text":"Module Path Purpose <code>pycusaxs.topology</code> <code>pycusaxs/topology.py</code> Trajectory/topology loading via MDAnalysis <code>pycusaxs.main</code> <code>pycusaxs/main.py</code> CLI/GUI entry points and backend orchestration <code>pycusaxs.saxs_widget</code> <code>pycusaxs/saxs_widget.py</code> PySide6 widgets for the GUI Root launcher <code>main.py</code> Thin wrapper calling <code>pycusaxs.main:main</code>"},{"location":"api/python/#classes","title":"Classes","text":""},{"location":"api/python/#topology","title":"<code>Topology</code>","text":"<ul> <li>Module: <code>pycusaxs.topology</code></li> <li>Constructor: <code>Topology(tpr_file: str, xtc_file: str)</code></li> <li>Responsibilities:</li> <li>Loads a GROMACS topology/trajectory into an <code>MDAnalysis.Universe</code>.</li> <li>Builds a connectivity graph (<code>networkx.Graph</code>) to classify molecules (proteins, water, ions, others).</li> <li>Stores convenient subsets (<code>protein_atoms</code>, molecule lists) for downstream analysis.</li> <li>Key Methods:</li> <li><code>iter_frames_stream(start: int, stop: int, step: int = 1) -&gt; Iterator[Dict]</code><ul> <li>Streams frames lazily; yields dicts with <code>frame</code>, <code>time</code>, <code>positions</code>, <code>box</code>.</li> <li>Positions and boxes are returned in Angstroms (nm-to-\u00c5 conversion applied).</li> </ul> </li> <li><code>get_atom_index() -&gt; Dict[str, List[int]]</code><ul> <li>Groups atom indices by element symbol; used to map scatterers inside CUDA.</li> </ul> </li> <li><code>read_frame(frame_number: int) -&gt; Timestep</code><ul> <li>Loads a specific frame; updates <code>self.ts</code> for access through getters.</li> </ul> </li> <li><code>get_box()</code>, <code>get_step()</code>, <code>get_time()</code>, <code>get_coordinates()</code><ul> <li>Accessors for the currently loaded frame (raise <code>RuntimeError</code> if <code>read_frame</code> was not invoked).</li> </ul> </li> <li><code>count_molecules() -&gt; Tuple[int, int, int, int, int]</code><ul> <li>Returns totals for all molecules and per-class breakdown.</li> </ul> </li> <li>Properties: <code>n_frames</code>, <code>n_atoms</code></li> <li>Notes: Suppresses certain MDAnalysis warnings; expects topology and trajectory to be compatible.</li> </ul>"},{"location":"api/python/#saxsparameterswindow","title":"<code>SaxsParametersWindow</code>","text":"<ul> <li>Module: <code>pycusaxs.saxs_widget</code></li> <li>Base Class: <code>QWidget</code></li> <li>Purpose: High-level GUI container combining required and advanced parameter forms, plus output display.</li> <li>Key Methods:</li> <li><code>execute()</code> (default implementation)<ul> <li>Collects parameters, echoes them in the output pane. Overridden by <code>SaxsMainWindow</code> to run the backend.</li> </ul> </li> <li><code>show_advanced_dialog()</code><ul> <li>Opens the modal dialog containing advanced options.</li> </ul> </li> <li><code>_init_ui()</code><ul> <li>Builds the widget layout; not intended for external use but useful when customizing the GUI.</li> </ul> </li> </ul>"},{"location":"api/python/#requiredparameterswidget","title":"<code>RequiredParametersWidget</code>","text":"<ul> <li>Module: <code>pycusaxs.saxs_widget</code></li> <li>Purpose: Form for required CLI-equivalent fields (<code>topology</code>, <code>trajectory</code>, <code>grid</code>, <code>begin</code>, <code>end</code>).</li> <li>Method: <code>parameters() -&gt; Dict[str, Any]</code></li> <li>Validates grid input (1 or 3 integers) and returns an ordered dictionary of values.</li> </ul>"},{"location":"api/python/#advancedparameterswidget","title":"<code>AdvancedParametersWidget</code>","text":"<ul> <li>Module: <code>pycusaxs.saxs_widget</code></li> <li>Purpose: Form for optional fields (output path, dt, order, scaled grid, scale factor, bin/qcut, solvent details, help flag).</li> <li>Method: <code>parameters() -&gt; Dict[str, Any]</code></li> <li>Converts widget values into an ordered dictionary consumed by the GUI runner.</li> </ul>"},{"location":"api/python/#saxsmainwindow","title":"<code>SaxsMainWindow</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Inherits: <code>SaxsParametersWindow</code></li> <li>Override: <code>execute()</code></li> <li>Validates required parameters, merges advanced ones, invokes <code>cuda_connect</code>, displays results or GUI errors.</li> <li>Error Display: Shows error dialogs for validation failures or backend errors</li> <li>Result Display: Renders backend summary and molecule counts in the output panel</li> </ul>"},{"location":"api/python/#functions","title":"Functions","text":""},{"location":"api/python/#build_output_pathsbase-str-frame_range-range-listpath","title":"<code>build_output_paths(base: str, frame_range: range) -&gt; List[Path]</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Expand a user-provided output base (file or directory) into per-frame PDB paths used for frame export.</li> <li>Behavior: Handles single-frame runs, directories, and default naming (<code>trajectory_frame_{frame:05d}.pdb</code>).</li> <li>Security (v0.1.0):</li> <li>Sanitizes paths using <code>resolve()</code> to prevent symlink attacks</li> <li>Validates paths are within current working directory or home directory</li> <li>Rejects paths outside allowed directories with <code>ValueError</code></li> <li>Handles <code>OSError</code> and <code>RuntimeError</code> during path resolution</li> </ul>"},{"location":"api/python/#_invoke_cuda_backendrequired_params-dictstr-any-advanced_params-dictstr-any-topology-topology-liststr","title":"<code>_invoke_cuda_backend(required_params: Dict[str, Any], advanced_params: Dict[str, Any], topology: Topology) -&gt; List[str]</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Imports <code>pycusaxs_cuda</code>, assembles keyword arguments, and calls the wrapped C++ backend.</li> <li>Return: List containing the formatted configuration summary (empty if backend unavailable or raises an exception).</li> </ul>"},{"location":"api/python/#cuda_connectrequired_params-dictstr-any-advanced_params-dictstr-any-iterablestr","title":"<code>cuda_connect(required_params: Dict[str, Any], advanced_params: Dict[str, Any]) -&gt; Iterable[str]</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Responsibilities:</li> <li>Validates filesystem inputs, frame bounds, and stride.</li> <li>Instantiates <code>Topology</code> and gathers molecule statistics.</li> <li>Invokes the CUDA backend and returns the combined textual output (counts + backend summary).</li> <li>Security &amp; Validation (v0.1.0):</li> <li>Path Sanitization:<ul> <li>Resolves topology and trajectory paths to absolute paths</li> <li>Validates paths are within CWD or home directory</li> <li>Raises <code>ValueError</code> for paths outside allowed directories</li> </ul> </li> <li>Input Validation:<ul> <li>Checks files exist before processing</li> <li>Validates frame range (begin &lt; end)</li> <li>Validates all numeric parameters are within acceptable ranges</li> </ul> </li> </ul>"},{"location":"api/python/#_run_clinamespace-argparsenamespace-int","title":"<code>_run_cli(namespace: argparse.Namespace) -&gt; int</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Executes the non-GUI code path; handles argument parsing errors, backend failures, and exit codes (0 success / 1 failure).</li> </ul>"},{"location":"api/python/#_run_gui-int","title":"<code>_run_gui() -&gt; int</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Launches the PySide6 application and returns its exit code.</li> </ul>"},{"location":"api/python/#mainargv-optionalliststr-none-int","title":"<code>main(argv: Optional[List[str]] = None) -&gt; int</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Entry point for CLI/GUI selection. Without arguments, launches the GUI; otherwise parses CLI arguments and calls <code>_run_cli</code>.</li> <li>Integration: Exposed both as console script <code>saxs-widget</code> and via <code>python -m pycusaxs.main</code>.</li> <li>Return: Exit code (0 for success, 1 for failure)</li> </ul>"},{"location":"api/python/#_parse_grid_valuesvalue-str-tupleint-int-int","title":"<code>_parse_grid_values(value: str) -&gt; tuple[int, int, int]</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Parse grid size from command-line string (e.g., \"128\" or \"128,128,128\")</li> <li>Validation: Ensures 1 or 3 values, all positive integers</li> <li>Return: Tuple of (nx, ny, nz)</li> </ul>"},{"location":"api/python/#_build_cli_parser-argparseargumentparser","title":"<code>_build_cli_parser() -&gt; argparse.ArgumentParser</code>","text":"<ul> <li>Module: <code>pycusaxs.main</code></li> <li>Purpose: Constructs the argument parser with all CLI options</li> <li>Special Handling:</li> <li>Detects <code>gui</code> as first argument to launch GUI mode</li> <li>Grid size accepts single or triple values</li> <li>Type conversions for all numeric parameters</li> </ul>"},{"location":"api/python/#gui-widget-helpers","title":"GUI Widget Helpers","text":"<ul> <li><code>RequiredParametersWidget._parse_grid_size()</code> ensures the grid input contains either one or three integers.</li> <li>Advanced widget uses <code>QSpinBox</code>/<code>QDoubleSpinBox</code> to enforce numeric ranges (e.g., stride \u2265 1).</li> <li><code>AdvancedParametersWidget</code> provides tooltips and help text for all advanced options.</li> </ul>"},{"location":"api/python/#root-launcher","title":"Root Launcher","text":""},{"location":"api/python/#main-in-mainpy","title":"<code>main()</code> in <code>main.py</code>","text":"<ul> <li>Calls <code>pycusaxs.main.main()</code> and exits with its status code, enabling <code>python main.py</code> as a shorthand.</li> </ul>"},{"location":"api/python/#error-handling","title":"Error Handling","text":"<ul> <li>CLI and GUI propagate user-facing errors via <code>ValueError</code>, <code>FileNotFoundError</code>, and GUI dialogs (<code>QMessageBox</code>).</li> <li>Backend failures bubble up as generic <code>Exception</code> objects, which are rendered as strings in the GUI or printed to stderr in the CLI.</li> </ul>"},{"location":"api/python/#exception-hierarchy-v010","title":"Exception Hierarchy (v0.1.0)","text":"<p>Python \u2192 C++ \u2192 Python Flow: 1. Python Input Validation: <code>ValueError</code> for invalid parameters, <code>FileNotFoundError</code> for missing files 2. C++ Backend Validation: <code>std::invalid_argument</code> for configuration errors, <code>std::runtime_error</code> for execution failures 3. Exception Translation: C++ exceptions properly translated to Python via pybind11:    - <code>std::invalid_argument</code> \u2192 <code>ValueError</code>    - <code>std::runtime_error</code> \u2192 <code>RuntimeError</code>    - Generic exceptions \u2192 <code>RuntimeError</code> with \"CuSAXS error:\" prefix</p> <p>Security Exceptions: - Path outside allowed directories \u2192 <code>ValueError</code> - Invalid file permissions \u2192 <code>ValueError</code> or <code>FileNotFoundError</code> - File I/O failures \u2192 <code>RuntimeError</code> from C++ backend</p>"},{"location":"api/python/#extending-the-python-layer","title":"Extending the Python Layer","text":"<ul> <li>To expose new backend options, update:</li> <li>CLI argument parser (<code>_build_cli_parser</code>).</li> <li>GUI widgets (add fields in <code>AdvancedParametersWidget</code> or <code>RequiredParametersWidget</code>).</li> <li>Parameter mapping in <code>cuda_connect</code> and <code>_invoke_cuda_backend</code>.</li> <li>Additional MDAnalysis-based analyses can be slotted into <code>Topology</code> or separate helper modules before passing frame data to the backend.</li> </ul>"},{"location":"api/python/#best-practices-v010","title":"Best Practices (v0.1.0)","text":"<p>Security: - Always validate and sanitize user-provided file paths - Use <code>Path.resolve()</code> to get absolute paths and detect symlink traversal - Validate paths are within expected directories (CWD or home) - Check file existence and permissions before processing</p> <p>Error Handling: - Provide specific, actionable error messages - Validate inputs early (fail fast) - Use appropriate exception types for different error categories - Include context in error messages (file names, parameter values)</p> <p>Performance: - Use streaming iteration for large trajectories - Release GIL during CPU-intensive operations - Validate parameters before expensive operations</p>"},{"location":"api/python/#usage-examples","title":"Usage Examples","text":""},{"location":"api/python/#basic-topology-analysis","title":"Basic Topology Analysis","text":"<pre><code>from pycusaxs.topology import Topology\n\n# Load trajectory\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\n\n# Print system information\nprint(f\"Total atoms: {topo.n_atoms}\")\nprint(f\"Total frames: {topo.n_frames}\")\n\n# Molecular composition\ntotal, protein, water, ions, other = topo.count_molecules()\nprint(f\"Proteins: {protein}\")\nprint(f\"Waters: {water}\")\nprint(f\"Ions: {ions}\")\n\n# Atom grouping by element\natom_index = topo.get_atom_index()\nfor element, indices in atom_index.items():\n    print(f\"{element}: {len(indices)} atoms\")\n</code></pre>"},{"location":"api/python/#streaming-frames","title":"Streaming Frames","text":"<pre><code>from pycusaxs.topology import Topology\n\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\n\n# Stream frames efficiently (memory-friendly for large trajectories)\nfor frame_data in topo.iter_frames_stream(start=0, stop=100, step=10):\n    frame_num = frame_data['frame']\n    time = frame_data['time']\n    positions = frame_data['positions']  # NumPy array in Angstroms\n    box = frame_data['box']  # Box dimensions\n\n    print(f\"Frame {frame_num} at {time:.2f} ps\")\n    print(f\"  Box: {box[0]:.2f} x {box[1]:.2f} x {box[2]:.2f} \u00c5\")\n</code></pre>"},{"location":"api/python/#complete-saxs-workflow","title":"Complete SAXS Workflow","text":"<pre><code>from pycusaxs.main import cuda_connect\n\n# Configure calculation\nrequired = {\n    \"topology\": \"/path/to/system.tpr\",\n    \"trajectory\": \"/path/to/traj.xtc\",\n    \"grid_size\": [128, 128, 128],\n    \"initial_frame\": 0,\n    \"last_frame\": 999\n}\n\nadvanced = {\n    \"dt\": 10,              # Process every 10th frame\n    \"order\": 4,            # B-spline order\n    \"bin_size\": 0.01,      # 0.01 \u00c5\u207b\u00b9 histogram bins\n    \"qcut\": 0.5,           # 0.5 \u00c5\u207b\u00b9 cutoff\n    \"scale_factor\": 2.0,   # Grid scaling\n    \"out\": \"saxs.dat\",     # Output file\n    \"simulation\": \"nvt\"    # NVT ensemble\n}\n\n# Run SAXS calculation\ntry:\n    results = cuda_connect(required, advanced)\n    for line in results:\n        print(line)\nexcept ValueError as e:\n    print(f\"Validation error: {e}\")\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept RuntimeError as e:\n    print(f\"Backend error: {e}\")\n</code></pre>"},{"location":"api/python/#gui-customization","title":"GUI Customization","text":"<pre><code>from PySide6.QtWidgets import QApplication\nfrom pycusaxs.main import SaxsMainWindow\nimport sys\n\napp = QApplication(sys.argv)\n\n# Create custom window\nwindow = SaxsMainWindow()\nwindow.setWindowTitle(\"Custom SAXS Analysis\")\nwindow.resize(800, 600)\n\n# Pre-fill some parameters (optional)\n# Access widgets via window attributes and set values\n\nwindow.show()\nsys.exit(app.exec())\n</code></pre>"},{"location":"api/python/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<pre><code>from pathlib import Path\nfrom pycusaxs.main import cuda_connect\n\ndef safe_saxs_calculation(tpr_path: str, xtc_path: str):\n    \"\"\"Safe SAXS calculation with comprehensive error handling.\"\"\"\n\n    # Validate files exist\n    tpr = Path(tpr_path)\n    xtc = Path(xtc_path)\n\n    if not tpr.exists():\n        raise FileNotFoundError(f\"Topology not found: {tpr}\")\n    if not xtc.exists():\n        raise FileNotFoundError(f\"Trajectory not found: {xtc}\")\n\n    # Configure with validated paths\n    required = {\n        \"topology\": str(tpr.resolve()),\n        \"trajectory\": str(xtc.resolve()),\n        \"grid_size\": [64, 64, 64],\n        \"initial_frame\": 0,\n        \"last_frame\": 100\n    }\n\n    advanced = {\n        \"dt\": 1,\n        \"out\": \"output/saxs.dat\"\n    }\n\n    try:\n        # Run calculation\n        results = cuda_connect(required, advanced)\n        return results\n    except ValueError as e:\n        print(f\"Invalid parameter: {e}\")\n        raise\n    except RuntimeError as e:\n        print(f\"Calculation failed: {e}\")\n        raise\n\n# Usage\ntry:\n    output = safe_saxs_calculation(\"system.tpr\", \"traj.xtc\")\n    for line in output:\n        print(line)\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    exit(1)\n</code></pre> <p>Refer to the module source files for exact signatures and implementation details.</p>"},{"location":"development/architecture/","title":"Architecture","text":"<p>This page describes the overall architecture and design of pyCuSAXS, including the project structure, technology stack, and data flow.</p>"},{"location":"development/architecture/#project-overview","title":"Project Overview","text":"<p>pyCuSAXS is designed as a hybrid Python/C++ application that combines:</p> <ul> <li>Python Layer: User interfaces (CLI/GUI) and trajectory handling</li> <li>C++/CUDA Backend: High-performance SAXS calculations on GPU</li> <li>pybind11 Bindings: Seamless Python-C++ interoperability</li> </ul>"},{"location":"development/architecture/#project-structure","title":"Project Structure","text":"<pre><code>pyCuSAXS/\n\u251c\u2500\u2500 pycusaxs/              # Python package\n\u2502   \u251c\u2500\u2500 __init__.py        # Package initialization\n\u2502   \u251c\u2500\u2500 main.py            # CLI/GUI entry point\n\u2502   \u251c\u2500\u2500 topology.py        # MDAnalysis integration\n\u2502   \u2514\u2500\u2500 saxs_widget.py     # PySide6 GUI components\n\u2502\n\u251c\u2500\u2500 cpp-src/               # C++/CUDA backend\n\u2502   \u251c\u2500\u2500 pybind/            # Python bindings\n\u2502   \u2502   \u2514\u2500\u2500 cuda_bindings.cpp  # pybind11 wrapper\n\u2502   \u251c\u2500\u2500 Exec/              # Execution orchestration\n\u2502   \u2502   \u251c\u2500\u2500 RunSaxs.cu     # Main pipeline controller\n\u2502   \u2502   \u2514\u2500\u2500 Options.cpp    # Global configuration\n\u2502   \u251c\u2500\u2500 Saxs/              # SAXS computation kernels\n\u2502   \u2502   \u251c\u2500\u2500 saxsKernel.cu  # Host-side kernel manager\n\u2502   \u2502   \u2514\u2500\u2500 saxsDeviceKernels.cu  # GPU kernels\n\u2502   \u251c\u2500\u2500 System/            # Coordinate transformations\n\u2502   \u2502   \u251c\u2500\u2500 Cell.cpp       # Box geometry handling\n\u2502   \u2502   \u2514\u2500\u2500 AtomCounter.cpp # Solvent density calculation\n\u2502   \u251c\u2500\u2500 Utilities/         # Mathematical utilities\n\u2502   \u2502   \u251c\u2500\u2500 BSpline.cpp    # B-spline modulation\n\u2502   \u2502   \u2514\u2500\u2500 Scattering.cpp # Form factor database\n\u2502   \u2514\u2500\u2500 include/           # Header files\n\u2502       \u251c\u2500\u2500 CudaSaxsInterface.h  # Main API\n\u2502       \u2514\u2500\u2500 *.h            # Component headers\n\u2502\n\u251c\u2500\u2500 docs/                  # Documentation\n\u2502   \u251c\u2500\u2500 getting-started/   # Installation and quickstart\n\u2502   \u251c\u2500\u2500 user-guide/        # User documentation\n\u2502   \u251c\u2500\u2500 algorithm/         # Algorithm details\n\u2502   \u251c\u2500\u2500 api/               # API reference\n\u2502   \u2514\u2500\u2500 development/       # Developer guides\n\u2502\n\u251c\u2500\u2500 CMakeLists.txt         # Build configuration\n\u251c\u2500\u2500 pyproject.toml         # Python packaging\n\u251c\u2500\u2500 requirements.txt       # Python dependencies\n\u251c\u2500\u2500 setup.py               # Build script\n\u2514\u2500\u2500 README.md              # Project overview\n</code></pre>"},{"location":"development/architecture/#technology-stack","title":"Technology Stack","text":""},{"location":"development/architecture/#python-layer","title":"Python Layer","text":""},{"location":"development/architecture/#pyside6","title":"PySide6","text":"<p>Purpose: Graphical user interface</p> <p>Components:</p> <ul> <li><code>QWidget</code> - Base GUI components</li> <li><code>QMainWindow</code> - Application window</li> <li><code>QFileDialog</code> - File selection</li> <li><code>QMessageBox</code> - Error dialogs</li> </ul> <p>Files:</p> <ul> <li><code>pycusaxs/saxs_widget.py</code> - GUI widgets</li> <li><code>pycusaxs/main.py</code> - Main window implementation</li> </ul>"},{"location":"development/architecture/#mdanalysis","title":"MDAnalysis","text":"<p>Purpose: Trajectory and topology parsing</p> <p>Features:</p> <ul> <li>Multi-format support (GROMACS, AMBER, CHARMM, etc.)</li> <li>Efficient frame iteration</li> <li>Atom selection language</li> <li>Coordinate transformations</li> </ul> <p>Files:</p> <ul> <li><code>pycusaxs/topology.py</code> - Wrapper around MDAnalysis</li> </ul> <p>Key Classes:</p> <ul> <li><code>Universe</code> - System container</li> <li><code>AtomGroup</code> - Atom selections</li> <li><code>Timestep</code> - Frame data</li> </ul>"},{"location":"development/architecture/#networkx","title":"NetworkX","text":"<p>Purpose: Molecular graph construction</p> <p>Usage:</p> <ul> <li>Identify connected components (molecules)</li> <li>Classify molecular types (protein, water, ions)</li> <li>Count molecules</li> </ul> <p>Files:</p> <ul> <li><code>pycusaxs/topology.py</code> - Graph-based molecule analysis</li> </ul>"},{"location":"development/architecture/#numpy","title":"NumPy","text":"<p>Purpose: Numerical operations</p> <p>Usage:</p> <ul> <li>Coordinate arrays</li> <li>Mathematical operations</li> <li>Data type conversions</li> </ul>"},{"location":"development/architecture/#ccuda-backend","title":"C++/CUDA Backend","text":""},{"location":"development/architecture/#cuda-runtime-cufft","title":"CUDA Runtime &amp; cuFFT","text":"<p>Purpose: GPU acceleration and FFT</p> <p>Components:</p> <ul> <li>CUDA Runtime: Kernel execution, memory management</li> <li>cuFFT: Optimized 3D Fourier transforms</li> </ul> <p>Files:</p> <ul> <li><code>cpp-src/Saxs/saxsKernel.cu</code> - cuFFT integration</li> <li><code>cpp-src/Saxs/saxsDeviceKernels.cu</code> - CUDA kernels</li> </ul> <p>Key Operations:</p> <ul> <li>Grid-based density assignment</li> <li>3D real-to-complex FFT</li> <li>Histogram accumulation</li> </ul>"},{"location":"development/architecture/#thrust","title":"Thrust","text":"<p>Purpose: GPU data structures and algorithms</p> <p>Features:</p> <ul> <li><code>device_vector</code> - GPU memory management (RAII)</li> <li>Parallel algorithms</li> <li>Exception-safe cleanup</li> </ul> <p>Files:</p> <ul> <li>Most <code>.cu</code> files use Thrust containers</li> </ul> <p>Example:</p> <pre><code>thrust::device_vector&lt;float&gt; d_density(grid_size);\n// Automatic cleanup when out of scope\n</code></pre>"},{"location":"development/architecture/#pybind11","title":"pybind11","text":"<p>Purpose: Python-C++ bindings</p> <p>Features:</p> <ul> <li>Automatic type conversion</li> <li>Exception translation</li> <li>GIL management</li> <li>NumPy integration</li> </ul> <p>Files:</p> <ul> <li><code>cpp-src/pybind/cuda_bindings.cpp</code> - Main binding module</li> </ul> <p>Interface:</p> <pre><code>PYBIND11_MODULE(pycusaxs_cuda, m) {\n    m.def(\"run\", &amp;run_cuda_saxs, \"Run SAXS calculation\");\n}\n</code></pre>"},{"location":"development/architecture/#fmt-library","title":"fmt Library","text":"<p>Purpose: Modern C++ string formatting</p> <p>Usage:</p> <ul> <li>Configuration banners</li> <li>Error messages</li> <li>Output formatting</li> </ul> <p>Files:</p> <ul> <li><code>cpp-src/Exec/Options.cpp</code> - Banner formatting</li> <li><code>cpp-src/Exec/RunSaxs.cu</code> - Timing output</li> </ul>"},{"location":"development/architecture/#component-architecture","title":"Component Architecture","text":""},{"location":"development/architecture/#python-components","title":"Python Components","text":""},{"location":"development/architecture/#topology-topologypy","title":"Topology (<code>topology.py</code>)","text":"<p>Responsibilities:</p> <ul> <li>Load GROMACS topology and trajectory</li> <li>Parse atomic structure</li> <li>Build connectivity graph</li> <li>Classify molecules</li> <li>Stream frames efficiently</li> </ul> <p>Key Methods:</p> <pre><code>class Topology:\n    def __init__(tpr_file, xtc_file)\n    def count_molecules() -&gt; (total, protein, water, ions, other)\n    def get_atom_index() -&gt; Dict[str, List[int]]\n    def iter_frames_stream(start, stop, step) -&gt; Iterator[Dict]\n</code></pre> <p>Dependencies:</p> <ul> <li>MDAnalysis</li> <li>NetworkX</li> <li>NumPy</li> </ul>"},{"location":"development/architecture/#main-module-mainpy","title":"Main Module (<code>main.py</code>)","text":"<p>Responsibilities:</p> <ul> <li>Argument parsing (CLI)</li> <li>Parameter validation</li> <li>Backend orchestration</li> <li>GUI instantiation</li> </ul> <p>Key Functions:</p> <pre><code>def cuda_connect(required_params, advanced_params) -&gt; Iterable[str]\ndef _invoke_cuda_backend(...) -&gt; List[str]\ndef main(argv) -&gt; int\n</code></pre> <p>Entry Points:</p> <ul> <li><code>python -m pycusaxs.main</code> - CLI or GUI</li> <li><code>saxs-widget</code> - Console script</li> </ul>"},{"location":"development/architecture/#gui-widgets-saxs_widgetpy","title":"GUI Widgets (<code>saxs_widget.py</code>)","text":"<p>Components:</p> <pre><code>SaxsParametersWindow\n\u251c\u2500\u2500 RequiredParametersWidget\n\u2502   \u251c\u2500\u2500 Topology file selector\n\u2502   \u251c\u2500\u2500 Trajectory file selector\n\u2502   \u251c\u2500\u2500 Grid size input\n\u2502   \u2514\u2500\u2500 Frame range inputs\n\u251c\u2500\u2500 AdvancedParametersDialog\n\u2502   \u251c\u2500\u2500 Output path\n\u2502   \u251c\u2500\u2500 Grid parameters\n\u2502   \u251c\u2500\u2500 Histogram parameters\n\u2502   \u2514\u2500\u2500 Solvent parameters\n\u2514\u2500\u2500 Output display panel\n</code></pre> <p>Inheritance:</p> <pre><code>QWidget\n\u2514\u2500\u2500 SaxsParametersWindow\n    \u2514\u2500\u2500 SaxsMainWindow (overrides execute())\n</code></pre>"},{"location":"development/architecture/#ccuda-components","title":"C++/CUDA Components","text":""},{"location":"development/architecture/#options-optionscpph","title":"Options (<code>Options.cpp/h</code>)","text":"<p>Purpose: Global configuration singleton</p> <p>Data:</p> <ul> <li>Grid dimensions (<code>nx</code>, <code>ny</code>, <code>nz</code>)</li> <li>Scaled grid (<code>nnx</code>, <code>nny</code>, <code>nnz</code>)</li> <li>Parameters (<code>order</code>, <code>sigma</code>, <code>Dq</code>, <code>Qcut</code>)</li> <li>File paths</li> <li>Solvent settings</li> </ul> <p>Usage: Accessed by all backend components</p>"},{"location":"development/architecture/#runsaxs-runsaxscuh","title":"RunSaxs (<code>RunSaxs.cu/h</code>)","text":"<p>Purpose: Pipeline orchestration</p> <p>Responsibilities:</p> <ul> <li>Frame iteration</li> <li>GIL management</li> <li>Double-buffered loading</li> <li>Kernel invocation</li> <li>Output writing</li> </ul> <p>Key Method:</p> <pre><code>void RunSaxs::Run(py::object Topol, int beg, int end, int dt)\n</code></pre> <p>Threading:</p> <ul> <li>Acquires GIL for Python access</li> <li>Releases GIL during GPU computation</li> <li>Synchronizes when needed</li> </ul>"},{"location":"development/architecture/#saxskernel-saxskernelcuh","title":"saxsKernel (<code>saxsKernel.cu/h</code>)","text":"<p>Purpose: GPU computation manager</p> <p>Responsibilities:</p> <ul> <li>CUDA memory allocation</li> <li>cuFFT plan management</li> <li>Kernel launch orchestration</li> <li>Histogram accumulation</li> </ul> <p>Key Method:</p> <pre><code>void saxsKernel::runPKernel(FrameData &amp;frame)\n</code></pre> <p>Pipeline Stages:</p> <ol> <li>Coordinate transformation</li> <li>Density assignment</li> <li>Padding &amp; supersampling</li> <li>FFT</li> <li>Form factor application</li> <li>Intensity calculation</li> <li>Histogram binning</li> </ol>"},{"location":"development/architecture/#device-kernels-saxsdevicekernelscu","title":"Device Kernels (<code>saxsDeviceKernels.cu</code>)","text":"<p>CUDA Kernels:</p> <ul> <li><code>rhoCartKernel</code> - Density grid assignment</li> <li><code>paddingKernel</code> - Solvent padding calculation</li> <li><code>superDensityKernel</code> - Grid supersampling</li> <li><code>scatterKernel</code> - Form factor application</li> <li><code>modulusKernel</code> - Intensity calculation</li> <li><code>calculate_histogram</code> - Binning</li> </ul> <p>Thread Organization:</p> <pre><code>dim3 blockSize(256);\ndim3 gridSize((N + blockSize.x - 1) / blockSize.x);\nkernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(...);\n</code></pre>"},{"location":"development/architecture/#cell-cellcpph","title":"Cell (<code>Cell.cpp/h</code>)","text":"<p>Purpose: Coordinate system transformations</p> <p>Methods:</p> <ul> <li><code>calculateMatrices()</code> - Compute CO/OC matrices</li> <li><code>getCO()</code> - Cell-to-orthonormal matrix</li> <li><code>getOC()</code> - Orthonormal-to-cell matrix</li> </ul> <p>Supports: Orthorhombic and triclinic boxes</p>"},{"location":"development/architecture/#bspline-bsplinecpph","title":"BSpline (<code>BSpline.cpp/h</code>)","text":"<p>Purpose: B-spline interpolation utilities</p> <p>Components:</p> <ul> <li><code>BSpmod</code> class - B-spline modulation factors</li> <li><code>generateModulation()</code> - Compute Fourier space corrections</li> <li>Order 1-8 support</li> </ul>"},{"location":"development/architecture/#scattering-scatteringcpph","title":"Scattering (<code>Scattering.cpp/h</code>)","text":"<p>Purpose: Atomic form factor database</p> <p>Data:</p> <ul> <li>Tabulated coefficients for all elements</li> <li>9-parameter form factor fit: \\(f(q) = \\sum_{i=1}^4 a_i e^{-b_i q^2/(4\\pi)^2} + c\\)</li> </ul> <p>Methods:</p> <ul> <li>Look up by element symbol</li> <li>Interpolate for arbitrary q values</li> </ul>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":""},{"location":"development/architecture/#high-level-flow","title":"High-Level Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   User Input    \u2502 (CLI args or GUI)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Topology Load  \u2502 (MDAnalysis)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Frame Streaming \u2502 (Python iterator)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  CUDA Backend   \u2502 (C++/CUDA)\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Transform \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502  Density  \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502  Padding  \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502    FFT    \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502 Scattering\u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502 Histogram \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SAXS Profile    \u2502 (Output file)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#detailed-frame-processing","title":"Detailed Frame Processing","text":"<pre><code>Python Thread                GPU Stream\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nLoad Frame n\n  \u2502 GIL held\n  \u251c\u2500&gt; Extract coords\n  \u251c\u2500&gt; Extract box\n  \u2514\u2500&gt; Create FrameData\n      \u2502\n      v\nTransfer to GPU \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Coords in device memory\n  \u2502 GIL released            \u2502\n  \u2502                         v\n  \u2502                    Transform Kernel\n  \u2502                         \u2502\n  \u2502                         v\nLoad Frame n+1         Density Kernel\n  \u2502 GIL held                \u2502\n  \u251c\u2500&gt; Extract coords        v\n  \u2502                    Padding Kernel\n  \u2514\u2500&gt; Create FrameData      \u2502\n      \u2502                     v\n      \u2502                FFT Execution\n      \u2502                     \u2502\n      v                     v\nWait for GPU \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500  Histogram Update\n  \u2502 GIL held\n  v\nProcess Results\n</code></pre>"},{"location":"development/architecture/#memory-layout","title":"Memory Layout","text":"<p>CPU Side:</p> <pre><code>Python Objects\n  \u2502\n  v\nNumPy Arrays (coordinates, box)\n  \u2502\n  v\nstd::vector&lt;float&gt; (C++ staging)\n</code></pre> <p>GPU Side:</p> <pre><code>Device Memory Layout:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  d_coords_x      \u2502 Float array [n_atoms]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_coords_y      \u2502 Float array [n_atoms]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_coords_z      \u2502 Float array [n_atoms]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_density       \u2502 Float array [nx\u00d7ny\u00d7nz]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_density_scaled\u2502 Float array [nnx\u00d7nny\u00d7nnz]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_fft_buffer    \u2502 Complex array [nnx\u00d7nny\u00d7(nnz/2+1)]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_histogram_I   \u2502 Float array [n_bins]\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  d_histogram_N   \u2502 Int array [n_bins]\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#communication-patterns","title":"Communication Patterns","text":""},{"location":"development/architecture/#python-c","title":"Python \u2192 C++","text":"<p>Via pybind11:</p> <pre><code># Python side\nresults = pycusaxs_cuda.run(\n    obj_topology=topology_object,\n    topology=\"system.tpr\",\n    trajectory=\"trajectory.xtc\",\n    grid=[128, 128, 128],\n    # ...\n)\n</code></pre> <p>Automatic conversions:</p> <ul> <li>Python <code>list</code> \u2192 C++ <code>std::vector</code></li> <li>Python <code>str</code> \u2192 C++ <code>std::string</code></li> <li>Python <code>dict</code> \u2192 C++ function arguments</li> <li>Python <code>int/float</code> \u2192 C++ <code>int/float</code></li> </ul>"},{"location":"development/architecture/#c-python","title":"C++ \u2192 Python","text":"<p>Return values:</p> <pre><code>// C++ side\nreturn py::dict(\n    \"summary\"_a = summary_string,\n    \"nx\"_a = Options::nx,\n    \"ny\"_a = Options::ny,\n    // ...\n);\n</code></pre> <p>Exceptions:</p> <pre><code>try {\n    // C++ code\n} catch (std::invalid_argument&amp; e) {\n    throw py::value_error(e.what());  // \u2192 Python ValueError\n} catch (std::runtime_error&amp; e) {\n    throw py::runtime_error(e.what());  // \u2192 Python RuntimeError\n}\n</code></pre>"},{"location":"development/architecture/#python-gpu","title":"Python \u2194 GPU","text":"<p>Frame data transfer:</p> <pre><code># Python (NumPy array)\npositions = frame['positions']  # Shape: (n_atoms, 3)\n\n# \u2192 C++ conversion\nstd::vector&lt;float&gt; x_coords, y_coords, z_coords;\n\n# \u2192 GPU transfer\ncudaMemcpy(d_coords_x, x_coords.data(), size, cudaMemcpyHostToDevice);\n</code></pre> <p>Result retrieval:</p> <pre><code>// GPU \u2192 CPU\ncudaMemcpy(h_histogram, d_histogram, size, cudaMemcpyDeviceToHost);\n\n// CPU \u2192 File\nwrite_output_file(h_histogram, n_bins);\n</code></pre>"},{"location":"development/architecture/#build-system","title":"Build System","text":""},{"location":"development/architecture/#cmake-configuration","title":"CMake Configuration","text":"<p>Top-level CMakeLists.txt:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(pyCuSAXS LANGUAGES CXX CUDA)\n\n# Find dependencies\nfind_package(CUDAToolkit REQUIRED)\nfind_package(Python COMPONENTS Interpreter Development)\nfind_package(pybind11 REQUIRED)\n\n# CUDA setup\nenable_language(CUDA)\nset(CMAKE_CUDA_STANDARD 17)\nset(CMAKE_CXX_STANDARD 17)\n\n# Build shared library\nadd_library(pycusaxs_cuda MODULE\n    cpp-src/pybind/cuda_bindings.cpp\n    cpp-src/Exec/RunSaxs.cu\n    cpp-src/Saxs/saxsKernel.cu\n    # ... more sources\n)\n\n# Link libraries\ntarget_link_libraries(pycusaxs_cuda PRIVATE\n    CUDA::cudart\n    CUDA::cufft\n    pybind11::module\n)\n</code></pre>"},{"location":"development/architecture/#python-packaging","title":"Python Packaging","text":"<p>setup.py:</p> <pre><code>from setuptools import setup\nfrom setuptools.command.build_ext import build_ext\n\nsetup(\n    name='pycusaxs',\n    packages=['pycusaxs'],\n    ext_modules=[CMakeExtension('pycusaxs_cuda')],\n    cmdclass={'build_ext': CMakeBuild},\n    # ...\n)\n</code></pre> <p>Installation Flow:</p> <ol> <li><code>pip install .</code> invokes <code>setup.py</code></li> <li><code>setup.py</code> calls CMake</li> <li>CMake builds C++/CUDA code</li> <li>Shared library installed as Python module</li> <li>Python package installed</li> </ol>"},{"location":"development/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"development/architecture/#raii-resource-acquisition-is-initialization","title":"RAII (Resource Acquisition Is Initialization)","text":"<p>Used for:</p> <ul> <li>GPU memory (Thrust vectors)</li> <li>cuFFT plans (custom destructor)</li> <li>File handles (std::ofstream)</li> </ul> <p>Example:</p> <pre><code>saxsKernel::~saxsKernel() {\n    if (fft_plan != 0) {\n        cufftDestroy(fft_plan);  // Automatic cleanup\n    }\n}\n</code></pre>"},{"location":"development/architecture/#singleton-pattern","title":"Singleton Pattern","text":"<p>Options class:</p> <pre><code>class Options {\npublic:\n    static int nx, ny, nz;  // Global configuration\n    // No instances needed\n};\n</code></pre>"},{"location":"development/architecture/#iterator-pattern","title":"Iterator Pattern","text":"<p>Frame streaming:</p> <pre><code>def iter_frames_stream(self, start, stop, step=1):\n    for ts in self.universe.trajectory[start:stop:step]:\n        yield frame_data_dict\n</code></pre>"},{"location":"development/architecture/#factory-pattern","title":"Factory Pattern","text":"<p>Cell matrix creation:</p> <pre><code>static Cell createCell(box_dimensions);  // Factory method\n</code></pre>"},{"location":"development/architecture/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"development/architecture/#layered-error-handling","title":"Layered Error Handling","text":"<ol> <li>Python Layer: Input validation, file checks</li> <li>Binding Layer: Type conversion, exception translation</li> <li>C++ Layer: Logic errors, CUDA errors</li> <li>CUDA Layer: Device errors, memory failures</li> </ol>"},{"location":"development/architecture/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception (Python base)\n\u251c\u2500\u2500 ValueError (invalid parameters)\n\u251c\u2500\u2500 FileNotFoundError (missing files)\n\u251c\u2500\u2500 RuntimeError (CUDA errors)\n\u2514\u2500\u2500 MemoryError (GPU OOM)\n</code></pre>"},{"location":"development/architecture/#error-propagation","title":"Error Propagation","text":"<pre><code>CUDA Error\n  \u2502\n  v\nC++ Exception (std::runtime_error)\n  \u2502\n  v\npybind11 Translation\n  \u2502\n  v\nPython Exception (RuntimeError)\n  \u2502\n  v\nUser-facing Error Message\n</code></pre>"},{"location":"development/architecture/#threading-model","title":"Threading Model","text":""},{"location":"development/architecture/#python-gil-management","title":"Python GIL Management","text":"<p>Pattern:</p> <pre><code>{\n    py::gil_scoped_acquire acquire;\n    // Python operations\n    auto frame = load_python_frame();\n}  // GIL released\n\n// GPU operations (no GIL needed)\nprocess_on_gpu();\n\n{\n    py::gil_scoped_acquire acquire;\n    // Next Python operation\n}\n</code></pre>"},{"location":"development/architecture/#cuda-stream-model","title":"CUDA Stream Model","text":"<p>Single stream execution:</p> <ul> <li>All kernels in same CUDA stream</li> <li>Automatic ordering within stream</li> <li>Minimal synchronization needed</li> </ul> <p>Future: Multi-stream:</p> <ul> <li>Parallel frame processing</li> <li>Overlapped compute/transfer</li> <li>Requires refactoring</li> </ul>"},{"location":"development/architecture/#see-also","title":"See Also","text":"<ul> <li>Backend API - C++/CUDA API reference</li> <li>Python API - Python API reference</li> <li>Pipeline Details - Implementation details</li> <li>Contributing Guide - Development workflow</li> </ul>"},{"location":"development/changelog/","title":"Changelog","text":"<p>All notable changes to pyCuSAXS are documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"development/changelog/#010-2024","title":"[0.1.0] - 2024","text":""},{"location":"development/changelog/#added","title":"Added","text":""},{"location":"development/changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>15-30% throughput improvement for multi-frame trajectories</li> <li>Reduced GPU synchronization from 10 to 2 <code>cudaDeviceSynchronize()</code> calls per frame</li> <li>Optimized kernel launch configurations for better GPU utilization</li> <li>Double-buffered frame loading for CPU-GPU overlap</li> </ul>"},{"location":"development/changelog/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive API documentation for backend (C++/CUDA)</li> <li>Complete Python API reference</li> <li>Detailed algorithm and pipeline documentation</li> <li>User guides for CLI, GUI, and Python API</li> </ul>"},{"location":"development/changelog/#fixed","title":"Fixed","text":""},{"location":"development/changelog/#memory-safety","title":"Memory Safety","text":"<ul> <li>Fixed memory leak in <code>saxsKernel.cu</code>: BSpline object now properly deleted after use</li> <li>Added cuFFT plan cleanup in destructor to prevent resource leak</li> <li>Disabled buggy <code>scatterCalculation()</code> function with uninitialized memory</li> <li>Proper RAII patterns for all GPU resources</li> </ul>"},{"location":"development/changelog/#numerical-stability","title":"Numerical Stability","text":"<ul> <li>Fixed integer overflow in grid calculations: replaced <code>std::pow</code> with bitwise operations</li> <li>Added division-by-zero checks for <code>bin_size</code> parameter</li> <li>Validated array bounds for histogram indices to prevent buffer overflow</li> <li>Improved floating-point precision in coordinate transformations</li> </ul>"},{"location":"development/changelog/#exception-handling","title":"Exception Handling","text":"<ul> <li>Proper C++ \u2192 Python exception translation in pybind11 bindings</li> <li>Comprehensive input validation for:</li> <li>Grid sizes (must be positive, exactly 3 elements)</li> <li>Frame ranges (begin &lt; end, within trajectory bounds)</li> <li>Stride (must be positive)</li> <li>Spline order (1-8)</li> <li>Bin size and qcut (non-negative)</li> <li>Scale factor (positive)</li> <li>File I/O error checking before writing results:</li> <li>Validates file opens with <code>is_open()</code></li> <li>Checks write operations with <code>good()</code></li> <li>Validates close operations with <code>fail()</code></li> </ul>"},{"location":"development/changelog/#security","title":"Security","text":"<ul> <li>Path sanitization to prevent directory traversal attacks</li> <li>Input validation for all user-provided parameters</li> <li>Bounds checking on all array accesses</li> <li>Safe file operations with error handling</li> </ul>"},{"location":"development/changelog/#changed","title":"Changed","text":"<ul> <li>Improved error messages with context information</li> <li>Enhanced input validation across all interfaces (CLI, GUI, Python API)</li> <li>Better exception types for different error categories</li> <li>More informative console output with timing statistics</li> </ul>"},{"location":"development/changelog/#technical-details","title":"Technical Details","text":""},{"location":"development/changelog/#before-v010","title":"Before v0.1.0","text":"<pre><code>// Memory leak - BSpline object never deleted\nBSpline::BSpmod* bspline = new BSpline::BSpmod(order, nx, ny, nz);\n// ... use bspline ...\n// LEAK: No delete!\n\n// Integer overflow in grid calculations\nint grid_size = std::pow(n, 3);  // Overflows for large n\n\n// Missing error checks\nFILE* f = fopen(path, \"w\");\nfprintf(f, ...);  // No check if fopen succeeded\n</code></pre>"},{"location":"development/changelog/#after-v010","title":"After v0.1.0","text":"<pre><code>// Proper cleanup\nBSpline::BSpmod* bspline = new BSpline::BSpmod(order, nx, ny, nz);\n// ... use bspline ...\ndelete bspline;  // Properly freed\n\n// Safe integer operations\nint grid_size = nx * ny * nz;  // No overflow\n\n// Error checking\nstd::ofstream f(path);\nif (!f.is_open()) {\n    throw std::runtime_error(\"Failed to open file\");\n}\nf &lt;&lt; data;\nif (!f.good()) {\n    throw std::runtime_error(\"Failed to write data\");\n}\n</code></pre>"},{"location":"development/changelog/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"development/changelog/#gpu-synchronization-impact","title":"GPU Synchronization Impact","text":"Configuration Before v0.1.0 After v0.1.0 Improvement 50K atoms, 128\u00b3 grid, 1000 frames ~45 ms/frame ~35 ms/frame 22% faster 100K atoms, 128\u00b3 grid, 1000 frames ~70 ms/frame ~55 ms/frame 21% faster 200K atoms, 128\u00b3 grid, 1000 frames ~110 ms/frame ~85 ms/frame 23% faster <p>Benchmarked on NVIDIA RTX 3080</p>"},{"location":"development/changelog/#memory-leak-fix","title":"Memory Leak Fix","text":"<p>Before: Memory usage grew linearly with number of frames processed</p> <p>After: Constant memory usage regardless of trajectory length</p> <pre><code>Frames Processed: 10000\nMemory Usage Before: ~2.5 GB \u2192 ~15 GB (leak)\nMemory Usage After:  ~2.5 GB \u2192 ~2.5 GB (fixed)\n</code></pre>"},{"location":"development/changelog/#bug-fixes-summary","title":"Bug Fixes Summary","text":""},{"location":"development/changelog/#critical-fixes","title":"Critical Fixes","text":"<p>Memory Leak in saxsKernel</p> <p>Issue: BSpline object allocated but never freed Impact: Memory usage grew with trajectory length Fix: Added <code>delete</code> call after extracting modulation vectors Severity: Critical - could cause OOM on long trajectories</p> <p>Integer Overflow in Grid Calculations</p> <p>Issue: <code>std::pow(n, 3)</code> returned incorrect values for large grids Impact: Corrupted calculations, wrong results Fix: Replaced with bitwise operations and direct multiplication Severity: Critical - produced wrong results</p> <p>Uninitialized Memory in scatterCalculation</p> <p>Issue: Function used uninitialized arrays Impact: Random/garbage values in calculations Fix: Disabled function, use <code>scatterKernel</code> instead Severity: Critical - produced invalid results</p>"},{"location":"development/changelog/#important-fixes","title":"Important Fixes","text":"<p>Missing cuFFT Plan Cleanup</p> <p>Issue: cuFFT plan never destroyed Impact: GPU resource leak Fix: Added cleanup in destructor Severity: Important - leaked GPU resources</p> <p>No Histogram Bounds Checking</p> <p>Issue: Array access without bounds validation Impact: Potential buffer overflow Fix: Added <code>if (bin &gt;= 0 &amp;&amp; bin &lt; num_bins)</code> check Severity: Important - could crash on invalid data</p> <p>Division by Zero in Histogram</p> <p>Issue: No check for <code>bin_size == 0</code> Impact: Program crash Fix: Added validation before division Severity: Important - caused crashes</p>"},{"location":"development/changelog/#security-fixes","title":"Security Fixes","text":"<p>Path Traversal Prevention</p> <p>Issue: No sanitization of user-provided file paths Impact: Potential directory traversal attack Fix: Path resolution and validation Severity: Security - low risk in typical usage</p> <p>Input Validation</p> <p>Issue: Missing validation for many parameters Impact: Confusing errors or crashes Fix: Comprehensive validation with clear error messages Severity: Usability - improved user experience</p>"},{"location":"development/changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"development/changelog/#from-pre-v010-to-v010","title":"From Pre-v0.1.0 to v0.1.0","text":"<p>No Breaking Changes: The API remains compatible. Simply upgrade:</p> <pre><code>git pull\npip install --force-reinstall .\n</code></pre> <p>Benefits:</p> <ul> <li>Faster calculations (15-30% improvement)</li> <li>No memory leaks on long trajectories</li> <li>Better error messages</li> <li>More robust against invalid inputs</li> </ul> <p>Recommended Actions:</p> <ol> <li>Re-run benchmarks to see performance improvements</li> <li>Update scripts to handle new exception types (more specific errors)</li> <li>Check GPU memory usage - should be stable now</li> </ol>"},{"location":"development/changelog/#deprecations","title":"Deprecations","text":"<p>None in this release.</p>"},{"location":"development/changelog/#removed-features","title":"Removed Features","text":"<ul> <li><code>scatterCalculation()</code> function - Disabled due to uninitialized memory bug</li> <li>Migration: Already using <code>scatterKernel</code> by default, no action needed</li> </ul>"},{"location":"development/changelog/#known-issues","title":"Known Issues","text":""},{"location":"development/changelog/#current-limitations","title":"Current Limitations","text":"<ul> <li>No multi-GPU support: Only uses single GPU</li> <li>Single-threaded frame loading: CPU I/O not parallelized</li> <li>Limited to orthorhombic/triclinic boxes: No support for other geometries</li> </ul>"},{"location":"development/changelog/#planned-fixes","title":"Planned Fixes","text":"<p>See Contributing Guide for information on planned features and how to contribute.</p>"},{"location":"development/changelog/#development-notes","title":"Development Notes","text":""},{"location":"development/changelog/#testing","title":"Testing","text":"<p>Improved testing coverage:</p> <ul> <li>Unit tests for critical functions</li> <li>Integration tests for full pipeline</li> <li>Regression tests for bug fixes</li> <li>Performance benchmarks</li> </ul>"},{"location":"development/changelog/#code-quality","title":"Code Quality","text":"<ul> <li>Reduced compiler warnings to zero</li> <li>Added <code>-Wall -Wextra</code> to build</li> <li>Static analysis with clang-tidy</li> <li>Memory checking with valgrind/cuda-memcheck</li> </ul>"},{"location":"development/changelog/#contributors","title":"Contributors","text":"<p>Thanks to all contributors who helped identify and fix bugs!</p>"},{"location":"development/changelog/#references","title":"References","text":"<ul> <li>Algorithm Overview</li> <li>Performance Guide</li> <li>Backend API</li> <li>Contributing Guide</li> </ul> <p>Version: 0.1.0 Last Updated: 2024</p>"},{"location":"development/contributing/","title":"Contributing Guide","text":"<p>Thank you for your interest in contributing to pyCuSAXS! This guide will help you get started with development.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<p>Before contributing, ensure you have:</p> <ul> <li>Git</li> <li>CUDA Toolkit 11.0+</li> <li>CMake 3.20+</li> <li>C++17 compiler (GCC 9+, Clang 10+, or MSVC 2019+)</li> <li>Python 3.9+</li> <li>NVIDIA GPU for testing</li> </ul>"},{"location":"development/contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li>Fork and Clone</li> </ol> <pre><code># Fork the repository on GitHub, then:\ngit clone https://github.com/YOUR_USERNAME/pyCuSaxs.git\ncd pyCuSaxs\n</code></pre> <ol> <li>Create Virtual Environment</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <ol> <li>Install Dependencies</li> </ol> <pre><code>pip install -r requirements.txt\npip install -r requirements-dev.txt  # Development dependencies\n</code></pre> <ol> <li>Install in Development Mode</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>This allows you to modify Python code without reinstalling.</p> <ol> <li>Verify Installation</li> </ol> <pre><code>python -c \"import pycusaxs_cuda; print('OK')\"\nsaxs-widget  # Test GUI\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branch-strategy","title":"Branch Strategy","text":"<p>We use a simplified Git Flow:</p> <ul> <li><code>main</code> - Stable release branch</li> <li><code>develop</code> - Integration branch for features</li> <li><code>feature/*</code> - New features</li> <li><code>bugfix/*</code> - Bug fixes</li> <li><code>hotfix/*</code> - Critical production fixes</li> </ul>"},{"location":"development/contributing/#creating-a-feature-branch","title":"Creating a Feature Branch","text":"<pre><code>git checkout develop\ngit pull origin develop\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Write Code</li> <li>Follow coding standards (see below)</li> <li>Add tests for new functionality</li> <li> <p>Update documentation</p> </li> <li> <p>Test Locally</p> </li> </ol> <pre><code># Run tests\npytest tests/\n\n# Test specific module\npytest tests/test_topology.py\n\n# Check code style\nflake8 pycusaxs/\nblack --check pycusaxs/\n</code></pre> <ol> <li>Build and Test C++ Code</li> </ol> <pre><code># Clean rebuild\nrm -rf build/\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Debug\ncmake --build build\n\n# Run with debug symbols\ngdb python\n&gt; run -m pycusaxs.main ...\n</code></pre> <ol> <li>Commit Changes</li> </ol> <pre><code>git add .\ngit commit -m \"Add feature: your feature description\"\n</code></pre> <p>Commit Message Format:</p> <pre><code>&lt;type&gt;: &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre> <p>Types:    - <code>feat:</code> New feature    - <code>fix:</code> Bug fix    - <code>docs:</code> Documentation    - <code>style:</code> Formatting    - <code>refactor:</code> Code restructuring    - <code>perf:</code> Performance improvement    - <code>test:</code> Tests    - <code>build:</code> Build system</p> <p>Example:</p> <pre><code>feat: Add multi-GPU support for frame processing\n\nImplements parallel processing across multiple GPUs using CUDA streams.\nEach GPU processes a subset of frames independently.\n\nCloses #123\n</code></pre> <ol> <li>Push and Create Pull Request</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a Pull Request on GitHub targeting the <code>develop</code> branch.</p>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<p>We follow PEP 8 with some modifications:</p> <ul> <li>Line length: 100 characters (not 79)</li> <li>Quotes: Prefer double quotes</li> <li>Imports: Grouped and sorted (use <code>isort</code>)</li> </ul> <p>Formatting:</p> <pre><code># Auto-format code\nblack pycusaxs/\n\n# Sort imports\nisort pycusaxs/\n\n# Check style\nflake8 pycusaxs/\n</code></pre> <p>Example:</p> <pre><code>\"\"\"Module docstring.\n\nDetailed description of module purpose.\n\"\"\"\n\nimport os\nimport sys\nfrom typing import List, Dict, Optional\n\nimport numpy as np\nfrom PySide6.QtWidgets import QWidget\n\n\nclass MyClass:\n    \"\"\"Class docstring.\n\n    Detailed description of class.\n    \"\"\"\n\n    def __init__(self, param: int) -&gt; None:\n        \"\"\"Initialize class.\n\n        Args:\n            param: Parameter description\n        \"\"\"\n        self.param = param\n\n    def my_method(self, arg: str) -&gt; List[int]:\n        \"\"\"Method description.\n\n        Args:\n            arg: Argument description\n\n        Returns:\n            Return value description\n\n        Raises:\n            ValueError: When argument is invalid\n        \"\"\"\n        if not arg:\n            raise ValueError(\"Argument cannot be empty\")\n        return [1, 2, 3]\n</code></pre>"},{"location":"development/contributing/#c-style","title":"C++ Style","text":"<p>We follow a modified Google C++ Style Guide:</p> <ul> <li>Indentation: 4 spaces (not tabs)</li> <li>Braces: Opening brace on same line</li> <li>Naming:</li> <li>Classes: <code>PascalCase</code></li> <li>Functions: <code>camelCase</code></li> <li>Variables: <code>snake_case</code></li> <li>Constants: <code>UPPER_CASE</code></li> <li>Member variables: prefix with <code>m_</code> or suffix with <code>_</code></li> </ul> <p>Example:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;cuda_runtime.h&gt;\n\nnamespace cusaxs {\n\n/**\n * @brief Brief class description\n *\n * Detailed class description.\n */\nclass MyClass {\npublic:\n    /**\n     * @brief Constructor\n     * @param size Grid size\n     */\n    explicit MyClass(int size);\n\n    /**\n     * @brief Compute SAXS profile\n     * @param coords Atomic coordinates\n     * @return SAXS intensity array\n     */\n    std::vector&lt;float&gt; computeSaxs(const std::vector&lt;float&gt;&amp; coords);\n\nprivate:\n    int grid_size_;\n    std::vector&lt;float&gt; data_;\n};\n\n}  // namespace cusaxs\n</code></pre>"},{"location":"development/contributing/#cuda-style","title":"CUDA Style","text":"<ul> <li>Kernel names: <code>camelCaseKernel</code> suffix</li> <li>Device functions: <code>__device__</code> prefix clearly marked</li> <li>Grid/block sizing: Use <code>dim3</code> for clarity</li> </ul> <p>Example:</p> <pre><code>/**\n * @brief Density assignment kernel\n * @param coords Atomic coordinates [n_atoms \u00d7 3]\n * @param density Output density grid [nx \u00d7 ny \u00d7 nz]\n * @param n_atoms Number of atoms\n */\n__global__ void densityAssignmentKernel(\n    const float* coords,\n    float* density,\n    int n_atoms,\n    int nx, int ny, int nz\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (idx &lt; n_atoms) {\n        // Kernel logic\n        float3 pos = make_float3(\n            coords[idx * 3 + 0],\n            coords[idx * 3 + 1],\n            coords[idx * 3 + 2]\n        );\n\n        // ... computation ...\n    }\n}\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#python-tests","title":"Python Tests","text":"<p>We use <code>pytest</code> for Python testing.</p> <p>Running Tests:</p> <pre><code># All tests\npytest\n\n# Specific test file\npytest tests/test_topology.py\n\n# Specific test function\npytest tests/test_topology.py::test_load_topology\n\n# With coverage\npytest --cov=pycusaxs --cov-report=html\n</code></pre> <p>Writing Tests:</p> <pre><code># tests/test_topology.py\n\nimport pytest\nfrom pycusaxs.topology import Topology\n\n\ndef test_load_topology():\n    \"\"\"Test topology loading.\"\"\"\n    topo = Topology(\"test_data/system.tpr\", \"test_data/trajectory.xtc\")\n    assert topo.n_atoms &gt; 0\n    assert topo.n_frames &gt; 0\n\n\ndef test_invalid_file():\n    \"\"\"Test error handling for missing files.\"\"\"\n    with pytest.raises(FileNotFoundError):\n        Topology(\"nonexistent.tpr\", \"nonexistent.xtc\")\n\n\n@pytest.fixture\ndef sample_topology():\n    \"\"\"Fixture for reusable topology.\"\"\"\n    return Topology(\"test_data/system.tpr\", \"test_data/trajectory.xtc\")\n\n\ndef test_molecule_count(sample_topology):\n    \"\"\"Test molecule counting.\"\"\"\n    total, protein, water, ions, other = sample_topology.count_molecules()\n    assert total &gt; 0\n    assert protein &gt;= 0\n</code></pre>"},{"location":"development/contributing/#c-tests","title":"C++ Tests","text":"<p>For C++ code, consider using Google Test or Catch2.</p> <p>Example with Google Test:</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n#include \"Cell.h\"\n\nTEST(CellTest, OrthogonalBox) {\n    std::vector&lt;float&gt; box = {10.0, 20.0, 30.0};\n    Cell cell = Cell::createCell(box);\n\n    auto CO = cell.getCO();\n    EXPECT_FLOAT_EQ(CO[0][0], 10.0);\n    EXPECT_FLOAT_EQ(CO[1][1], 20.0);\n    EXPECT_FLOAT_EQ(CO[2][2], 30.0);\n}\n\nTEST(CellTest, TriclinicBox) {\n    std::vector&lt;std::vector&lt;float&gt;&gt; box = {\n        {10.0, 0.0, 0.0},\n        {5.0, 15.0, 0.0},\n        {2.0, 3.0, 20.0}\n    };\n    Cell cell = Cell::createCell(box);\n\n    auto CO = cell.getCO();\n    EXPECT_FLOAT_EQ(CO[0][0], 10.0);\n    EXPECT_FLOAT_EQ(CO[1][0], 5.0);\n}\n</code></pre>"},{"location":"development/contributing/#integration-tests","title":"Integration Tests","text":"<p>Test the full pipeline:</p> <pre><code>def test_full_saxs_calculation():\n    \"\"\"Test complete SAXS workflow.\"\"\"\n    from pycusaxs.main import cuda_connect\n\n    required = {\n        \"topology\": \"test_data/system.tpr\",\n        \"trajectory\": \"test_data/trajectory.xtc\",\n        \"grid_size\": [64, 64, 64],\n        \"initial_frame\": 0,\n        \"last_frame\": 10\n    }\n\n    advanced = {\n        \"dt\": 1,\n        \"out\": \"test_output/saxs.dat\"\n    }\n\n    results = list(cuda_connect(required, advanced))\n    assert len(results) &gt; 0\n\n    # Check output file\n    import os\n    assert os.path.exists(\"test_output/saxs.dat\")\n\n    # Validate output format\n    import numpy as np\n    data = np.loadtxt(\"test_output/saxs.dat\")\n    assert data.shape[1] == 2  # q and I(q)\n    assert np.all(data[:, 0] &gt; 0)  # q &gt; 0\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#docstring-format","title":"Docstring Format","text":"<p>Python (Google Style):</p> <pre><code>def my_function(param1: int, param2: str) -&gt; List[int]:\n    \"\"\"Brief description.\n\n    Detailed description with more information about what\n    the function does and how it works.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When param1 is negative\n        TypeError: When param2 is not a string\n\n    Example:\n        &gt;&gt;&gt; result = my_function(10, \"test\")\n        &gt;&gt;&gt; print(result)\n        [1, 2, 3, 4, 5]\n    \"\"\"\n    pass\n</code></pre> <p>C++ (Doxygen):</p> <pre><code>/**\n * @brief Brief description\n *\n * Detailed description.\n *\n * @param param1 Description of param1\n * @param param2 Description of param2\n * @return Description of return value\n * @throws std::invalid_argument When param1 is negative\n *\n * @code\n * MyClass obj(10);\n * auto result = obj.myMethod(param1, param2);\n * @endcode\n */\nReturnType myMethod(int param1, const std::string&amp; param2);\n</code></pre>"},{"location":"development/contributing/#updating-documentation","title":"Updating Documentation","text":"<p>When adding features:</p> <ol> <li>Update relevant .md files in <code>docs/</code></li> <li>Add examples to user guide</li> <li>Update API reference if public API changed</li> <li>Add to CHANGELOG.md</li> </ol> <p>Building Docs Locally:</p> <pre><code># Install MkDocs\npip install mkdocs-material\n\n# Serve documentation locally\nmkdocs serve\n\n# Open http://127.0.0.1:8000 in browser\n</code></pre>"},{"location":"development/contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"development/contributing/#1-new-python-feature","title":"1. New Python Feature","text":"<p>Steps:</p> <ol> <li>Create feature branch</li> <li>Add code to appropriate module</li> <li>Add tests</li> <li>Update docstrings</li> <li>Update user guide</li> <li>Create PR</li> </ol> <p>Example: Add new analysis method</p> <pre><code># pycusaxs/topology.py\n\ndef calculate_radius_of_gyration(self) -&gt; float:\n    \"\"\"Calculate radius of gyration.\n\n    Returns:\n        Radius of gyration in Angstroms\n\n    Raises:\n        RuntimeError: If no frame is loaded\n    \"\"\"\n    if self.ts is None:\n        raise RuntimeError(\"No frame loaded. Call read_frame() first.\")\n\n    coords = self.get_coordinates()\n    center = np.mean(coords, axis=0)\n    rg = np.sqrt(np.mean(np.sum((coords - center)**2, axis=1)))\n    return rg\n</code></pre>"},{"location":"development/contributing/#2-new-c-feature","title":"2. New C++ Feature","text":"<p>Steps:</p> <ol> <li>Declare in header file</li> <li>Implement in .cpp/.cu file</li> <li>Add to pybind11 bindings if needed</li> <li>Add tests</li> <li>Update documentation</li> </ol> <p>Example: Add new kernel</p> <pre><code>// cpp-src/Saxs/saxsDeviceKernels.cuh\n__global__ void myNewKernel(float* data, int size);\n\n// cpp-src/Saxs/saxsDeviceKernels.cu\n__global__ void myNewKernel(float* data, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx &lt; size) {\n        // Kernel implementation\n        data[idx] = /* computation */;\n    }\n}\n\n// cpp-src/Saxs/saxsKernel.cu\nvoid saxsKernel::runMyNewKernel() {\n    dim3 blockSize(256);\n    dim3 gridSize((size + blockSize.x - 1) / blockSize.x);\n    myNewKernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(d_data, size);\n}\n</code></pre>"},{"location":"development/contributing/#3-new-configuration-parameter","title":"3. New Configuration Parameter","text":"<p>Steps:</p> <ol> <li>Add to <code>CudaSaxsConfig</code> struct</li> <li>Update pybind11 wrapper</li> <li>Add to CLI parser</li> <li>Add to GUI widget</li> <li>Update documentation</li> </ol> <p>Example:</p> <pre><code>// cpp-src/include/CudaSaxsInterface.h\nstruct CudaSaxsConfig {\n    // ... existing fields ...\n    float new_parameter = 1.0;\n};\n\n// cpp-src/pybind/cuda_bindings.cpp\nm.def(\"run\", [](\n    // ... existing params ...\n    float new_parameter = 1.0\n) {\n    config.new_parameter = new_parameter;\n    // ...\n}, py::arg(\"new_parameter\") = 1.0);\n\n// pycusaxs/main.py\nparser.add_argument(\"--new-param\", type=float, default=1.0,\n                   help=\"Description of new parameter\")\n</code></pre>"},{"location":"development/contributing/#performance-optimization","title":"Performance Optimization","text":"<p>When optimizing:</p> <ol> <li>Profile first - Use <code>nvprof</code> or Nsight to identify bottlenecks</li> <li>Benchmark - Measure before and after</li> <li>Document - Explain optimization in comments</li> <li>Test - Ensure results are still correct</li> </ol> <p>Example profiling:</p> <pre><code>nsys profile -o profile python -m pycusaxs.main -s system.tpr -x traj.xtc -g 128 -b 0 -e 10\nnsys-ui profile.qdrep\n</code></pre>"},{"location":"development/contributing/#debugging","title":"Debugging","text":""},{"location":"development/contributing/#python-debugging","title":"Python Debugging","text":"<pre><code># IPython debugger\nimport ipdb; ipdb.set_trace()\n\n# PDB\nimport pdb; pdb.set_trace()\n\n# VS Code debugger\n# Set breakpoint in editor, F5 to debug\n</code></pre>"},{"location":"development/contributing/#c-debugging","title":"C++ Debugging","text":"<pre><code># GDB\ngdb --args python -m pycusaxs.main -s system.tpr -x traj.xtc -g 64 -b 0 -e 1\n&gt; break saxsKernel.cu:123\n&gt; run\n&gt; backtrace\n&gt; print variable_name\n</code></pre>"},{"location":"development/contributing/#cuda-debugging","title":"CUDA Debugging","text":"<pre><code># cuda-gdb\ncuda-gdb --args python -m pycusaxs.main -s system.tpr -x traj.xtc -g 64 -b 0 -e 1\n\n# cuda-memcheck\ncuda-memcheck python -m pycusaxs.main -s system.tpr -x traj.xtc -g 64 -b 0 -e 1\n\n# Compute sanitizer (newer)\ncompute-sanitizer python -m pycusaxs.main ...\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure CI passes - All tests must pass</li> <li>Update CHANGELOG.md - Document your changes</li> <li>Request review - At least one maintainer review required</li> <li>Address feedback - Respond to all comments</li> <li>Squash commits - Clean up commit history if requested</li> <li>Merge - Maintainer will merge when approved</li> </ol>"},{"location":"development/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li> Code follows style guidelines</li> <li> Tests added for new functionality</li> <li> All tests pass</li> <li> Documentation updated</li> <li> CHANGELOG.md updated</li> <li> No merge conflicts</li> <li> Commit messages are descriptive</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Provide constructive feedback</li> <li>Focus on the code, not the person</li> <li>Help newcomers learn</li> </ul>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues for bugs and feature requests</li> <li>Discussions: GitHub Discussions for questions</li> <li>Email: [Maintainer email]</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"development/contributing/#see-also","title":"See Also","text":"<ul> <li>Architecture - System design</li> <li>Backend API - C++/CUDA API</li> <li>Python API - Python API</li> <li>Changelog - Version history</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>This guide covers all configuration parameters available in pyCuSAXS and how to optimize them for your calculations.</p>"},{"location":"getting-started/configuration/#parameter-categories","title":"Parameter Categories","text":"<p>pyCuSAXS parameters are organized into several categories:</p> <ul> <li>Grid Parameters: Control density grid resolution</li> <li>Histogram Parameters: Define binning in reciprocal space</li> <li>Solvent Parameters: Configure solvent models</li> <li>Performance Tuning: Optimize computation speed</li> </ul>"},{"location":"getting-started/configuration/#grid-parameters","title":"Grid Parameters","text":"<p>Grid parameters control the spatial resolution of the SAXS calculation.</p>"},{"location":"getting-started/configuration/#primary-grid-size-grid","title":"Primary Grid Size (<code>--grid</code>)","text":"<p>The primary density grid where atomic positions are mapped.</p> Parameter Type Description Recommended Values grid int or 3\u00d7int Primary density grid size 64-128 for most systems <p>Usage:</p> <pre><code># Cubic grid (same size in all dimensions)\n--grid 128\n\n# Non-cubic grid\n--grid 128,128,256\n</code></pre> <p>Choosing Grid Size</p> <ul> <li>64\u00b3: Fast, suitable for quick tests and small molecules</li> <li>128\u00b3: Good balance for most protein systems (recommended)</li> <li>256\u00b3: High resolution for detailed analysis (requires 8GB+ GPU memory)</li> </ul>"},{"location":"getting-started/configuration/#scaled-grid-size-grids","title":"Scaled Grid Size (<code>--gridS</code>)","text":"<p>The supersampled grid used for FFT calculations. If not specified, it's automatically calculated based on the scale factor.</p> Parameter Type Description Default gridS 3\u00d7int Scaled (supersampled) grid Auto-calculated or 2\u00d7 primary <p>Usage:</p> <pre><code># Explicit scaled grid\n--gridS 256,256,256\n\n# Auto-calculated based on Scale factor\n--Scale 2.0  # Creates gridS = 2 \u00d7 grid\n</code></pre>"},{"location":"getting-started/configuration/#scale-factor-scale","title":"Scale Factor (<code>--Scale</code>)","text":"<p>Controls the grid supersampling ratio (\u03c3).</p> Parameter Type Description Range Default Scale float Grid scaling factor (\u03c3) 1.0-3.0 1.0 <p>Usage:</p> <pre><code>--Scale 2.0  # 2\u00d7 oversampling\n</code></pre> <p>Grid Resolution</p> <p>The reciprocal space resolution is given by:</p> \\[\\Delta q = \\frac{2\\pi}{N \\cdot \\sigma \\cdot L}\\] <p>where N is grid dimension, \u03c3 is the scaling factor, and L is box length.</p>"},{"location":"getting-started/configuration/#b-spline-interpolation-order-order","title":"B-spline Interpolation Order (<code>--order</code>)","text":"<p>Order of B-spline interpolation for density assignment.</p> Parameter Type Description Range Default order int B-spline interpolation order 1-8 4 <p>Usage:</p> <pre><code>--order 6  # Higher accuracy, slower\n</code></pre> <p>Order Selection Guide:</p> <ul> <li>1-3: Fast but less accurate (not recommended)</li> <li>4: Good balance (default)</li> <li>5-6: Better accuracy for high-resolution work</li> <li>7-8: Maximum accuracy (slower, rarely needed)</li> </ul>"},{"location":"getting-started/configuration/#histogram-parameters","title":"Histogram Parameters","text":"<p>Control binning and range of the output SAXS profile.</p>"},{"location":"getting-started/configuration/#bin-size-bin-dq","title":"Bin Size (<code>--bin</code>, <code>--Dq</code>)","text":"<p>Width of histogram bins in reciprocal space.</p> Parameter Type Description Typical Range Default bin_size (Dq) float Histogram bin width (\u00c5\u207b\u00b9) 0.001-0.05 Auto <p>Usage:</p> <pre><code>--bin 0.01  # 0.01 \u00c5\u207b\u00b9 bins\n</code></pre> <p>Bin Size Selection</p> <ul> <li>0.001-0.005 \u00c5\u207b\u00b9: Very fine, good for detailed features</li> <li>0.01 \u00c5\u207b\u00b9: Standard resolution (recommended)</li> <li>0.02-0.05 \u00c5\u207b\u00b9: Coarse, faster binning</li> </ul>"},{"location":"getting-started/configuration/#q-cutoff-qcut-q","title":"Q Cutoff (<code>--qcut</code>, <code>-q</code>)","text":"<p>Maximum q value in the output profile.</p> Parameter Type Description Typical Range Default qcut float Reciprocal space cutoff (\u00c5\u207b\u00b9) 0.3-1.0 Auto <p>Usage:</p> <pre><code>--qcut 0.5  # Limit to q \u2264 0.5 \u00c5\u207b\u00b9\n</code></pre> <p>Cutoff Selection:</p> <ul> <li>0.3 \u00c5\u207b\u00b9: Low-angle scattering, overall shape</li> <li>0.5 \u00c5\u207b\u00b9: Standard SAXS range (recommended)</li> <li>1.0 \u00c5\u207b\u00b9: Wide-angle, requires finer grids</li> </ul>"},{"location":"getting-started/configuration/#solvent-parameters","title":"Solvent Parameters","text":"<p>Configure explicit solvent modeling for accurate background subtraction.</p>"},{"location":"getting-started/configuration/#water-model-water","title":"Water Model (<code>--water</code>)","text":"<p>Specify the water model used in your simulation.</p> Parameter Type Description Common Values water string Water model identifier <code>tip3p</code>, <code>tip4p</code>, <code>spc</code>, <code>spce</code> <p>Usage:</p> <pre><code>--water tip3p\n</code></pre> <p>Solvent Padding Mode</p> <p>When <code>--water</code> is specified, padding mode automatically switches to explicit (given densities). Otherwise, average mode is used (computed from border).</p>"},{"location":"getting-started/configuration/#ion-counts","title":"Ion Counts","text":"<p>Number of ions in the simulation box.</p> Parameter Type Description Usage sodium (<code>--na</code>) int Na\u207a ion count From topology chlorine (<code>--cl</code>) int Cl\u207b ion count From topology <p>Usage:</p> <pre><code>--na 150 --cl 150  # 150 mM NaCl\n</code></pre>"},{"location":"getting-started/configuration/#simulation-type-simulation","title":"Simulation Type (<code>--simulation</code>)","text":"<p>Ensemble type of your simulation.</p> Parameter Type Description Values simulation string Simulation ensemble <code>nvt</code>, <code>npt</code> <p>Usage:</p> <pre><code>--simulation nvt  # Constant volume\n</code></pre> <ul> <li>NVT: Constant number, volume, temperature</li> <li>NPT: Constant number, pressure, temperature</li> </ul>"},{"location":"getting-started/configuration/#performance-tuning","title":"Performance Tuning","text":"<p>Optimize calculation speed and resource usage.</p>"},{"location":"getting-started/configuration/#frame-stride-dt","title":"Frame Stride (<code>--dt</code>)","text":"<p>Step size for frame sampling.</p> Parameter Type Description Default dt int Frame stride/step 1 <p>Usage:</p> <pre><code>--dt 10  # Process every 10th frame\n</code></pre> <p>Sampling Strategy</p> <ul> <li>dt=1: All frames (best statistics, slowest)</li> <li>dt=5-10: Good balance (recommended)</li> <li>dt=20+: Quick analysis (fewer statistics)</li> </ul>"},{"location":"getting-started/configuration/#frame-range-begin-end","title":"Frame Range (<code>--begin</code>, <code>--end</code>)","text":"<p>Define which frames to process.</p> Parameter Type Description Default begin (<code>-b</code>) int Starting frame index 0 end (<code>-e</code>) int Ending frame index same as begin <p>Usage:</p> <pre><code>--begin 0 --end 999  # Process frames 0-999\n</code></pre>"},{"location":"getting-started/configuration/#parameter-optimization","title":"Parameter Optimization","text":""},{"location":"getting-started/configuration/#for-speed","title":"For Speed","text":"<p>Optimize for fast calculations (testing, exploration):</p> <pre><code>python -m pycusaxs.main \\\n    -s topology.tpr -x trajectory.xtc \\\n    --grid 64 \\\n    --order 4 \\\n    --dt 20 \\\n    --begin 0 --end 100 \\\n    --bin 0.02\n</code></pre>"},{"location":"getting-started/configuration/#for-accuracy","title":"For Accuracy","text":"<p>Optimize for high-quality results (publication):</p> <pre><code>python -m pycusaxs.main \\\n    -s topology.tpr -x trajectory.xtc \\\n    --grid 128 \\\n    --gridS 256,256,256 \\\n    --order 6 \\\n    --Scale 2.0 \\\n    --dt 5 \\\n    --begin 0 --end 999 \\\n    --bin 0.005 \\\n    --qcut 0.5\n</code></pre>"},{"location":"getting-started/configuration/#for-large-systems","title":"For Large Systems","text":"<p>Optimize for systems with many atoms:</p> <pre><code>python -m pycusaxs.main \\\n    -s large_system.tpr -x trajectory.xtc \\\n    --grid 128 \\  # Don't go larger unless needed\n    --order 4 \\\n    --dt 10 \\\n    --bin 0.01\n</code></pre>"},{"location":"getting-started/configuration/#configuration-file-support","title":"Configuration File Support","text":"<p>Currently, pyCuSAXS accepts parameters via command line. For complex workflows, consider using shell scripts:</p> <pre><code>#!/bin/bash\n# saxs_config.sh\n\nTOPOLOGY=\"system.tpr\"\nTRAJECTORY=\"trajectory.xtc\"\nGRID=\"128,128,128\"\nORDER=6\nSCALE=2.0\nBIN=0.01\nQCUT=0.5\n\npython -m pycusaxs.main \\\n    -s \"$TOPOLOGY\" \\\n    -x \"$TRAJECTORY\" \\\n    --grid \"$GRID\" \\\n    --order \"$ORDER\" \\\n    --Scale \"$SCALE\" \\\n    --bin \"$BIN\" \\\n    --qcut \"$QCUT\" \\\n    -o \"saxs_profile.dat\"\n</code></pre>"},{"location":"getting-started/configuration/#best-practices","title":"Best Practices","text":"<p>Grid Sizing</p> <ul> <li>Use powers of 2 for optimal FFT performance (64, 128, 256)</li> <li>Match grid size to system size (1-2 \u00c5 per grid point)</li> <li>Consider GPU memory limits</li> </ul> <p>Histogram Binning</p> <ul> <li>Choose bin size based on desired q resolution</li> <li>Smaller bins = more detail but more noise</li> <li>Use qcut to limit output range</li> </ul> <p>Solvent Modeling</p> <ul> <li>Always specify water model if using explicit solvent</li> <li>Count ions from topology output</li> <li>Match simulation type to your MD protocol</li> </ul> <p>Performance</p> <ul> <li>Start with small grids and frame ranges for testing</li> <li>Increase stride for long trajectories</li> <li>Monitor GPU memory with <code>nvidia-smi</code></li> </ul>"},{"location":"getting-started/configuration/#parameter-summary-table","title":"Parameter Summary Table","text":"Category Parameter CLI Flag Type Default Range Grid Primary grid <code>--grid</code>, <code>-g</code> int/3\u00d7int Required 16-512 Scaled grid <code>--gridS</code> 3\u00d7int Auto - Scale factor <code>--Scale</code> float 1.0 1.0-3.0 Spline order <code>--order</code> int 4 1-8 Histogram Bin size <code>--bin</code>, <code>--Dq</code> float Auto 0.001+ Q cutoff <code>--qcut</code>, <code>-q</code> float Auto 0.1+ Solvent Water model <code>--water</code> string None - Sodium count <code>--na</code> int 0 0+ Chlorine count <code>--cl</code> int 0 0+ Simulation type <code>--simulation</code> string nvt nvt/npt I/O Topology <code>-s</code>, <code>--topology</code> path Required - Trajectory <code>-x</code>, <code>--trajectory</code> path Required - Output <code>-o</code>, <code>--out</code> path saxs.dat - Frames Begin frame <code>-b</code>, <code>--begin</code> int 0 0+ End frame <code>-e</code>, <code>--end</code> int same as begin 0+ Frame stride <code>--dt</code> int 1 1+"},{"location":"getting-started/configuration/#see-also","title":"See Also","text":"<ul> <li>Command Line Interface - Complete CLI reference</li> <li>Algorithm Overview - How parameters affect calculations</li> <li>Performance - Performance optimization guide</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers the installation of pyCuSAXS on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/installation/#hardware-requirements","title":"Hardware Requirements","text":"<p>GPU Requirements</p> <ul> <li>NVIDIA GPU with CUDA Compute Capability 6.0+ (Pascal architecture or newer)</li> <li>At least 4GB GPU memory recommended</li> </ul>"},{"location":"getting-started/installation/#software-requirements","title":"Software Requirements","text":"<p>Before installing pyCuSAXS, ensure you have the following software installed:</p> Software Minimum Version Purpose CUDA Toolkit 11.0+ GPU acceleration and cuFFT CMake 3.20+ Build configuration C++ Compiler GCC 9+, Clang 10+, or MSVC 2019+ Compiling C++17 code Python 3.9+ Python interface and scripting NVIDIA Driver Compatible with CUDA version GPU device control <p>Checking CUDA Version</p> <p>Verify your CUDA installation: <pre><code>nvcc --version\n</code></pre></p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-standard-installation-recommended","title":"Method 1: Standard Installation (Recommended)","text":"<p>This is the recommended method for most users:</p> <pre><code># Create and activate virtual environment (optional but recommended)\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Build and install pyCuSAXS\npip install .\n</code></pre> <p>Virtual Environment</p> <p>Using a virtual environment isolates pyCuSAXS dependencies from your system Python, preventing conflicts.</p>"},{"location":"getting-started/installation/#method-2-development-installation","title":"Method 2: Development Installation","text":"<p>For developers who want to modify the code:</p> <pre><code># Install in editable mode for development\npip install -e .\n\n# Or build manually with CMake\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j$(nproc)\n</code></pre> <p>Development Mode</p> <p>Editable installation (<code>-e</code> flag) allows you to modify Python and C++ code without reinstalling. However, C++ changes require rebuilding the extension module.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that everything is working correctly:</p>"},{"location":"getting-started/installation/#check-cuda-backend","title":"Check CUDA Backend","text":"<pre><code># Check if CUDA backend is available\npython -c \"import pycusaxs_cuda; print('CUDA backend loaded successfully')\"\n</code></pre>"},{"location":"getting-started/installation/#launch-gui","title":"Launch GUI","text":"<pre><code># Launch graphical interface\nsaxs-widget\n</code></pre> <p>If the GUI launches without errors, your installation is successful!</p>"},{"location":"getting-started/installation/#check-python-package","title":"Check Python Package","text":"<pre><code># Verify Python package\npython -c \"import pycusaxs; print('pyCuSAXS package loaded successfully')\"\n\n# Check GPU availability\nnvidia-smi\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-notes","title":"Platform-Specific Notes","text":"LinuxWindowsmacOS <p>Most Linux distributions work out of the box. Ensure your NVIDIA driver is up to date:</p> <pre><code># Check driver version\nnvidia-smi\n\n# Update driver (Ubuntu/Debian)\nsudo apt update\nsudo apt install nvidia-driver-525  # or latest version\n</code></pre> <p>On Windows, you may need to:</p> <ol> <li>Install Visual Studio 2019 or newer (for MSVC compiler)</li> <li>Ensure CUDA Toolkit is in your PATH</li> <li>Use <code>venv\\Scripts\\activate</code> instead of <code>source venv/bin/activate</code></li> </ol> <p>macOS Support</p> <p>pyCuSAXS requires NVIDIA CUDA, which is not supported on macOS with Apple Silicon. macOS support is limited to older Intel Macs with NVIDIA GPUs.</p>"},{"location":"getting-started/installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":""},{"location":"getting-started/installation/#cuda-toolkit-not-found","title":"CUDA Toolkit Not Found","text":"<p>If CMake cannot find your CUDA installation:</p> <pre><code># Set CUDA path explicitly\nexport CUDA_HOME=/usr/local/cuda\nexport PATH=$CUDA_HOME/bin:$PATH\nexport LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATH\n</code></pre>"},{"location":"getting-started/installation/#compiler-errors","title":"Compiler Errors","text":"<p>If you encounter C++ compiler errors:</p> <ol> <li>Verify your compiler version is compatible with your CUDA version</li> <li>For CUDA 11.x, use GCC 9-11 (GCC 12+ may have issues)</li> <li>Check NVIDIA's CUDA compatibility matrix</li> </ol>"},{"location":"getting-started/installation/#build-failures","title":"Build Failures","text":"<pre><code># Clean build and try again\nrm -rf build/\npip install --force-reinstall .\n</code></pre>"},{"location":"getting-started/installation/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code># Ensure all Python dependencies are installed\npip install -r requirements.txt\n\n# Install MDAnalysis extras for all trajectory formats\npip install MDAnalysis[all]\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete:</p> <ul> <li>Quick Start Guide - Run your first SAXS calculation</li> <li>Configuration - Learn about configuration options</li> <li>Command Line Interface - Explore CLI options</li> <li>Graphical User Interface - Use the GUI application</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with pyCuSAXS in just a few minutes! This guide shows you how to run your first SAXS calculation.</p>"},{"location":"getting-started/quickstart/#basic-example","title":"Basic Example","text":"<p>The simplest way to compute a SAXS profile from a trajectory:</p> <pre><code># Compute SAXS profile from trajectory\npython -m pycusaxs.main \\\n    --topology system.tpr \\\n    --trajectory trajectory.xtc \\\n    --grid 128,128,128 \\\n    --begin 0 \\\n    --end 100 \\\n    --dt 10 \\\n    --out saxs_profile.dat\n</code></pre> <p>This command will:</p> <ol> <li>Load the topology file (<code>system.tpr</code>) and trajectory (<code>trajectory.xtc</code>)</li> <li>Process frames 0-100, sampling every 10<sup>th</sup> frame</li> <li>Use a 128\u00b3 density grid for calculations</li> <li>Save the SAXS profile to <code>saxs_profile.dat</code></li> </ol> <p>Grid Size Selection</p> <p>Start with 64\u00b3 or 128\u00b3 grids for testing. Larger grids (256\u00b3) provide better resolution but require more GPU memory and computation time.</p>"},{"location":"getting-started/quickstart/#gui-mode","title":"GUI Mode","text":"<p>For interactive use, launch the graphical interface:</p> <pre><code># Launch graphical interface\nsaxs-widget\n\n# or alternatively\npython -m pycusaxs.main gui\n</code></pre> <p>The GUI provides:</p> <ul> <li>File browser for selecting topology and trajectory files</li> <li>Interactive parameter configuration</li> <li>Real-time progress feedback</li> <li>Configuration summary display</li> </ul> <p>GUI Benefits</p> <p>The GUI is perfect for exploring parameters and validating configurations before running large-scale calculations.</p>"},{"location":"getting-started/quickstart/#understanding-the-output","title":"Understanding the Output","text":""},{"location":"getting-started/quickstart/#output-file-format","title":"Output File Format","text":"<p>The output file (<code>saxs_profile.dat</code>) contains two columns:</p> <pre><code># Column 1: q (\u00c5\u207b\u00b9)\n# Column 2: I(q) (arbitrary units)\n   0.00100    1234.5678\n   0.00200    1123.4567\n   0.00300    1012.3456\n   ...\n</code></pre> <ul> <li>q: Scattering vector magnitude (\u00c5\u207b\u00b9)</li> <li>I(q): Scattering intensity (arbitrary units)</li> </ul>"},{"location":"getting-started/quickstart/#console-output","title":"Console Output","text":"<p>During execution, you'll see:</p> <pre><code>*************************************************\n*            Running CuSAXS                     *\n* Cell Grid               128 *  128 *  128     *\n* Supercell Grid          256 *  256 *  256     *\n* Order    4          Sigma      2.000          *\n* Bin Size 0.010      Q Cutoff   0.500          *\n* Padding             avg Border                *\n*************************************************\n\n--&gt; Frame:    0      Time Step: 0.00 fs\n--&gt; Frame:   10      Time Step: 10.00 fs\n...\n\nDone 100 Steps\nResults written to saxs_profile.dat\n\n=========================================================\n=                                                       =\n=                    CuSAXS Timing                     =\n=                                                       =\n=           CUDA Time:     25.43 ms/per step           =\n=           Read Time:     5.12 ms/per step            =\n=           Total Time:    30.55 ms/per step           =\n=                                                       =\n=========================================================\n</code></pre> <p>This shows:</p> <ul> <li>Configuration summary (grid sizes, parameters)</li> <li>Frame processing progress</li> <li>Performance timing statistics</li> </ul>"},{"location":"getting-started/quickstart/#common-use-cases","title":"Common Use Cases","text":""},{"location":"getting-started/quickstart/#case-1-quick-test-run","title":"Case 1: Quick Test Run","text":"<p>Test on a small number of frames first:</p> <pre><code>python -m pycusaxs.main \\\n    -s protein.tpr \\\n    -x trajectory.xtc \\\n    -g 64 \\\n    -b 0 -e 10 \\\n    -o test_saxs.dat\n</code></pre>"},{"location":"getting-started/quickstart/#case-2-production-run","title":"Case 2: Production Run","text":"<p>For production analysis with better statistics:</p> <pre><code>python -m pycusaxs.main \\\n    -s protein.tpr \\\n    -x md_trajectory.xtc \\\n    -g 128 \\\n    -b 0 -e 999 --dt 10 \\\n    --order 6 \\\n    --bin 0.01 --qcut 0.5 \\\n    -o production_saxs.dat\n</code></pre>"},{"location":"getting-started/quickstart/#case-3-with-explicit-solvent","title":"Case 3: With Explicit Solvent","text":"<p>For systems with explicit solvent:</p> <pre><code>python -m pycusaxs.main \\\n    -s solvated.tpr \\\n    -x md.xtc \\\n    -g 100 \\\n    --water tip3p \\\n    --na 150 --cl 150 \\\n    --simulation nvt \\\n    -o saxs_solvated.dat\n</code></pre>"},{"location":"getting-started/quickstart/#visualizing-results","title":"Visualizing Results","text":"<p>You can plot the SAXS profile using Python:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Load SAXS data\ndata = np.loadtxt('saxs_profile.dat')\nq = data[:, 0]\nI = data[:, 1]\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.loglog(q, I, 'b-', linewidth=2)\nplt.xlabel('q (\u00c5\u207b\u00b9)', fontsize=12)\nplt.ylabel('I(q) (a.u.)', fontsize=12)\nplt.title('SAXS Profile', fontsize=14)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig('saxs_plot.png', dpi=300)\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#whats-next","title":"What's Next?","text":"<p>Now that you've run your first calculation, explore more features:</p> Learn the CLIUse Python APIConfigure Advanced OptionsUnderstand the Algorithm <p>Command Line Interface - Master all CLI options and parameters</p> <p>Python API - Integrate SAXS calculations into your scripts</p> <p>Configuration - Fine-tune grid sizing, binning, and solvent models</p> <p>Algorithm Overview - Learn how SAXS calculations work</p>"},{"location":"getting-started/quickstart/#tips-for-best-results","title":"Tips for Best Results","text":"<p>Frame Sampling</p> <ul> <li>Use <code>--dt</code> to skip frames and reduce computation time</li> <li>Process 50-100 frames for good statistics</li> <li>More frames improve signal-to-noise but increase runtime</li> </ul> <p>Grid Resolution</p> <ul> <li>64\u00b3: Fast, suitable for preliminary analysis</li> <li>128\u00b3: Good balance of speed and accuracy (recommended)</li> <li>256\u00b3: High resolution, requires more memory</li> </ul> <p>Performance</p> <ul> <li>Start with small frame ranges for testing</li> <li>Monitor GPU memory usage with <code>nvidia-smi</code></li> <li>Use frame stride (<code>--dt</code>) to process large trajectories efficiently</li> </ul> <p>Common Pitfalls</p> <ul> <li>Ensure topology and trajectory are compatible</li> <li>Check that frame indices are within trajectory bounds</li> <li>Verify sufficient GPU memory for your grid size</li> </ul>"},{"location":"user-guide/cli/","title":"Command Line Interface","text":"<p>The pyCuSAXS command-line interface provides full control over SAXS calculations through terminal commands.</p>"},{"location":"user-guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>python -m pycusaxs.main [OPTIONS]\n</code></pre> <p>Alternative Invocation</p> <p>You can also use the installed command: <pre><code>saxs-widget [OPTIONS]  # GUI mode if no options\n</code></pre></p>"},{"location":"user-guide/cli/#required-parameters","title":"Required Parameters","text":"<p>These parameters must be specified for every calculation:</p>"},{"location":"user-guide/cli/#topology-file-s-topology","title":"Topology File (<code>-s</code>, <code>--topology</code>)","text":"<p>GROMACS topology file containing system structure information.</p> <pre><code>-s system.tpr\n--topology system.tpr\n</code></pre> <p>Supported Formats: - <code>.tpr</code> - GROMACS portable binary run input file (recommended)</p>"},{"location":"user-guide/cli/#trajectory-file-x-trajectory","title":"Trajectory File (<code>-x</code>, <code>--trajectory</code>)","text":"<p>MD trajectory file containing atomic coordinates over time.</p> <pre><code>-x trajectory.xtc\n--trajectory trajectory.xtc\n</code></pre> <p>Supported Formats: - <code>.xtc</code> - GROMACS compressed trajectory (recommended) - <code>.trr</code> - GROMACS full-precision trajectory - Other formats supported by MDAnalysis</p>"},{"location":"user-guide/cli/#grid-size-g-grid","title":"Grid Size (<code>-g</code>, <code>--grid</code>)","text":"<p>Density grid dimensions for SAXS calculations.</p> <pre><code># Cubic grid (same in all dimensions)\n--grid 128\n\n# Non-cubic grid\n--grid 128,128,256\n</code></pre> <p>Common Values: - <code>64</code> - Fast, lower resolution - <code>128</code> - Standard (recommended) - <code>256</code> - High resolution (requires more memory)</p>"},{"location":"user-guide/cli/#frame-range","title":"Frame Range","text":"<p>Define which frames to process from the trajectory.</p>"},{"location":"user-guide/cli/#begin-frame-b-begin","title":"Begin Frame (<code>-b</code>, <code>--begin</code>)","text":"<p>Starting frame index (0-based).</p> <pre><code>--begin 0  # Start from first frame\n-b 100     # Start from frame 100\n</code></pre>"},{"location":"user-guide/cli/#end-frame-e-end","title":"End Frame (<code>-e</code>, <code>--end</code>)","text":"<p>Ending frame index (inclusive).</p> <pre><code>--end 999  # Process up to frame 999\n-e 1000    # Process 1000 frames\n</code></pre> <p>Frame Indices</p> <p>Frame indices are 0-based. To process frames 1-1000 from your trajectory, use <code>--begin 0 --end 999</code>.</p>"},{"location":"user-guide/cli/#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/cli/#output-file-o-out","title":"Output File (<code>-o</code>, <code>--out</code>)","text":"<p>Specify output file path for the SAXS profile.</p> <pre><code>--out results/saxs_profile.dat\n-o my_saxs.dat\n</code></pre> <p>Default: <code>saxs.dat</code> in the current directory</p>"},{"location":"user-guide/cli/#frame-stride-dt","title":"Frame Stride (<code>--dt</code>)","text":"<p>Step size for frame sampling (process every Nth frame).</p> <pre><code>--dt 10  # Process every 10th frame\n</code></pre> <p>Default: 1 (process every frame)</p> <p>Usage Guide: - <code>dt=1</code>: Maximum statistics, slowest - <code>dt=5-10</code>: Good balance (recommended) - <code>dt=20+</code>: Quick analysis</p>"},{"location":"user-guide/cli/#b-spline-order-order","title":"B-spline Order (<code>--order</code>)","text":"<p>Interpolation order for density assignment (1-8).</p> <pre><code>--order 6  # Higher accuracy\n</code></pre> <p>Default: 4</p> <p>Guidelines: - 4: Good balance (default) - 5-6: Better accuracy for publication - 7-8: Maximum accuracy (rarely needed)</p>"},{"location":"user-guide/cli/#grid-scaling","title":"Grid Scaling","text":""},{"location":"user-guide/cli/#scale-factor-scale","title":"Scale Factor (<code>--Scale</code>)","text":"<p>Grid supersampling ratio (\u03c3).</p> <pre><code>--Scale 2.0  # 2\u00d7 oversampling\n</code></pre> <p>Default: 1.0</p>"},{"location":"user-guide/cli/#explicit-scaled-grid-grids","title":"Explicit Scaled Grid (<code>--gridS</code>)","text":"<p>Manually specify the supersampled grid dimensions.</p> <pre><code>--gridS 256,256,256\n</code></pre> <p>Default: Auto-calculated from <code>--Scale</code></p> <p>Grid Scaling</p> <p>The scaled grid is used for FFT calculations. Either specify <code>--Scale</code> (automatic) or <code>--gridS</code> (manual), but typically not both.</p>"},{"location":"user-guide/cli/#histogram-parameters","title":"Histogram Parameters","text":""},{"location":"user-guide/cli/#bin-size-bin-dq","title":"Bin Size (<code>--bin</code>, <code>--Dq</code>)","text":"<p>Histogram bin width in reciprocal space (\u00c5\u207b\u00b9).</p> <pre><code>--bin 0.01  # 0.01 \u00c5\u207b\u00b9 bins\n--Dq 0.005  # Finer binning\n</code></pre> <p>Common Values: - <code>0.005</code> - Fine resolution - <code>0.01</code> - Standard (recommended) - <code>0.02</code> - Coarse, faster</p>"},{"location":"user-guide/cli/#q-cutoff-qcut-q","title":"Q Cutoff (<code>--qcut</code>, <code>-q</code>)","text":"<p>Maximum q value in output (\u00c5\u207b\u00b9).</p> <pre><code>--qcut 0.5  # Limit to 0.5 \u00c5\u207b\u00b9\n-q 1.0      # Extended range\n</code></pre> <p>Typical Ranges: - <code>0.3</code> - Low-angle, overall shape - <code>0.5</code> - Standard SAXS (recommended) - <code>1.0</code> - Wide-angle</p>"},{"location":"user-guide/cli/#solvent-parameters","title":"Solvent Parameters","text":""},{"location":"user-guide/cli/#water-model-water","title":"Water Model (<code>--water</code>)","text":"<p>Specify water model for explicit solvation.</p> <pre><code>--water tip3p\n--water spce\n</code></pre> <p>Supported Models: - <code>tip3p</code>, <code>tip4p</code>, <code>tip5p</code> - <code>spc</code>, <code>spce</code> - Others as defined in the scattering database</p>"},{"location":"user-guide/cli/#ion-counts","title":"Ion Counts","text":"<p>Number of ions in the simulation box.</p> <pre><code>--na 150   # 150 sodium ions\n--cl 150   # 150 chloride ions\n</code></pre> <p>Default: 0 for both</p> <p>Getting Ion Counts</p> <p>Use the Python API to analyze your topology and get accurate ion counts: <pre><code>from pycusaxs.topology import Topology\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\ntotal, protein, water, ions, other = topo.count_molecules()\nprint(f\"Ions: {ions}\")\n</code></pre></p>"},{"location":"user-guide/cli/#simulation-type-simulation","title":"Simulation Type (<code>--simulation</code>)","text":"<p>Simulation ensemble type.</p> <pre><code>--simulation nvt  # Constant volume\n--simulation npt  # Constant pressure\n</code></pre> <p>Default: <code>nvt</code></p> <p>Options: - <code>nvt</code> - Constant number, volume, temperature - <code>npt</code> - Constant number, pressure, temperature</p>"},{"location":"user-guide/cli/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/cli/#example-1-basic-saxs-calculation","title":"Example 1: Basic SAXS Calculation","text":"<p>Minimal configuration for a quick SAXS profile:</p> <pre><code>python -m pycusaxs.main \\\n    -s protein.tpr \\\n    -x md_trajectory.xtc \\\n    -g 64,64,64 \\\n    -b 0 -e 999 --dt 10 \\\n    -o results/saxs.dat\n</code></pre> <p>This will:</p> <ul> <li>Process frames 0-999, every 10<sup>th</sup> frame (100 frames total)</li> <li>Use a 64\u00b3 grid for fast computation</li> <li>Save results to <code>results/saxs.dat</code></li> </ul>"},{"location":"user-guide/cli/#example-2-high-resolution-with-custom-grid-scaling","title":"Example 2: High-Resolution with Custom Grid Scaling","text":"<p>Production-quality calculation with fine control:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr \\\n    -x traj.xtc \\\n    -g 128 \\\n    --gridS 256,256,256 \\\n    --order 6 \\\n    --Scale 2.0 \\\n    --bin 0.01 --qcut 0.5 \\\n    -o high_res_saxs.dat\n</code></pre> <p>Features:</p> <ul> <li>128\u00b3 primary grid, 256\u00b3 scaled grid</li> <li>Order 6 B-spline interpolation</li> <li>Fine histogram binning (0.01 \u00c5\u207b\u00b9)</li> <li>Output limited to q \u2264 0.5 \u00c5\u207b\u00b9</li> </ul>"},{"location":"user-guide/cli/#example-3-with-explicit-solvent-model","title":"Example 3: With Explicit Solvent Model","text":"<p>For systems with explicit water and ions:</p> <pre><code>python -m pycusaxs.main \\\n    -s solvated.tpr \\\n    -x md.xtc \\\n    -g 100 \\\n    --water tip3p \\\n    --na 150 --cl 150 \\\n    --simulation nvt \\\n    -o saxs_solvated.dat\n</code></pre> <p>Features:</p> <ul> <li>TIP3P water model</li> <li>150 mM NaCl (150 Na\u207a, 150 Cl\u207b)</li> <li>NVT ensemble</li> </ul>"},{"location":"user-guide/cli/#example-4-quick-test-run","title":"Example 4: Quick Test Run","text":"<p>Fast test on a few frames:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr \\\n    -x trajectory.xtc \\\n    -g 64 \\\n    -b 0 -e 10 \\\n    -o test.dat\n</code></pre> <p>Features:</p> <ul> <li>Small grid (64\u00b3)</li> <li>Only 10 frames</li> <li>Fast validation before full run</li> </ul>"},{"location":"user-guide/cli/#example-5-full-production-run","title":"Example 5: Full Production Run","text":"<p>Complete configuration for publication-quality results:</p> <pre><code>python -m pycusaxs.main \\\n    --topology protein.tpr \\\n    --trajectory production.xtc \\\n    --grid 128 \\\n    --order 6 \\\n    --Scale 2.0 \\\n    --begin 0 \\\n    --end 999 \\\n    --dt 5 \\\n    --bin 0.005 \\\n    --qcut 0.5 \\\n    --water tip3p \\\n    --na 150 \\\n    --cl 150 \\\n    --simulation nvt \\\n    --out publication_saxs.dat\n</code></pre> <p>Features:</p> <ul> <li>All parameters explicitly specified</li> <li>High accuracy settings</li> <li>Explicit solvent model</li> <li>Fine histogram binning</li> <li>200 frames (every 5<sup>th</sup> from 1000)</li> </ul>"},{"location":"user-guide/cli/#parameter-combinations","title":"Parameter Combinations","text":""},{"location":"user-guide/cli/#for-speed","title":"For Speed","text":"<p>Optimized for fast calculations:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc \\\n    -g 64 --order 4 --dt 20 \\\n    -b 0 -e 100 --bin 0.02 \\\n    -o quick_saxs.dat\n</code></pre>"},{"location":"user-guide/cli/#for-accuracy","title":"For Accuracy","text":"<p>Optimized for high-quality results:</p> <pre><code>python -m pycusaxs.main \\\n    -s system.tpr -x trajectory.xtc \\\n    -g 128 --gridS 256,256,256 \\\n    --order 6 --Scale 2.0 \\\n    -b 0 -e 999 --dt 5 \\\n    --bin 0.005 --qcut 0.5 \\\n    -o accurate_saxs.dat\n</code></pre>"},{"location":"user-guide/cli/#shell-script-automation","title":"Shell Script Automation","text":"<p>For repeated calculations, create a shell script:</p> <pre><code>#!/bin/bash\n# run_saxs.sh - Automated SAXS calculation\n\n# Configuration\nTOPOLOGY=\"system.tpr\"\nTRAJECTORY=\"trajectory.xtc\"\nOUTPUT_DIR=\"results\"\nGRID=\"128\"\nORDER=6\nDT=10\n\n# Create output directory\nmkdir -p \"$OUTPUT_DIR\"\n\n# Run SAXS calculation\npython -m pycusaxs.main \\\n    -s \"$TOPOLOGY\" \\\n    -x \"$TRAJECTORY\" \\\n    -g \"$GRID\" \\\n    --order \"$ORDER\" \\\n    --dt \"$DT\" \\\n    -b 0 -e 999 \\\n    --bin 0.01 \\\n    --qcut 0.5 \\\n    -o \"$OUTPUT_DIR/saxs_profile.dat\"\n\necho \"SAXS calculation complete!\"\necho \"Results saved to $OUTPUT_DIR/saxs_profile.dat\"\n</code></pre> <p>Make executable and run:</p> <pre><code>chmod +x run_saxs.sh\n./run_saxs.sh\n</code></pre>"},{"location":"user-guide/cli/#batch-processing","title":"Batch Processing","text":"<p>Process multiple trajectories:</p> <pre><code>#!/bin/bash\n# batch_saxs.sh - Process multiple trajectories\n\nfor i in {1..10}; do\n    echo \"Processing trajectory $i...\"\n    python -m pycusaxs.main \\\n        -s system.tpr \\\n        -x trajectory_${i}.xtc \\\n        -g 128 -b 0 -e 999 --dt 10 \\\n        -o results/saxs_${i}.dat\ndone\n</code></pre>"},{"location":"user-guide/cli/#getting-help","title":"Getting Help","text":"<p>Display CLI help message:</p> <pre><code>python -m pycusaxs.main --help\n</code></pre>"},{"location":"user-guide/cli/#exit-codes","title":"Exit Codes","text":"<p>The CLI returns standard exit codes:</p> <ul> <li>0: Success</li> <li>1: Error (invalid parameters, file not found, calculation failure)</li> </ul> <p>Use in scripts:</p> <pre><code>if python -m pycusaxs.main -s system.tpr -x traj.xtc -g 128 -b 0 -e 100; then\n    echo \"SAXS calculation successful\"\nelse\n    echo \"SAXS calculation failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"user-guide/cli/#see-also","title":"See Also","text":"<ul> <li>Configuration - Detailed parameter descriptions</li> <li>Python API - Programmatic interface</li> <li>GUI Guide - Graphical interface</li> <li>Examples - Quick start examples</li> </ul>"},{"location":"user-guide/database/","title":"Database Management","text":"<p>pyCuSAXS includes an SQLite database system for storing and managing SAXS profiles, with special support for solvent subtraction workflows.</p>"},{"location":"user-guide/database/#overview","title":"Overview","text":"<p>The database system uses two separate databases:</p> <ul> <li>Reference Database: Read-only, contains pure solvent profiles (shipped with package)</li> <li>User Database: Read-write, stores your protein+solvent calculations</li> </ul>"},{"location":"user-guide/database/#database-locations","title":"Database Locations","text":"Database Path Purpose Reference <code>&lt;package&gt;/data/reference_solvents.db</code> Pure solvent reference profiles User <code>~/.local/share/pycusaxs/user_profiles.db</code> Your SAXS calculations"},{"location":"user-guide/database/#saving-profiles-to-database","title":"Saving Profiles to Database","text":""},{"location":"user-guide/database/#save-to-user-database","title":"Save to User Database","text":"<p>Use <code>--save-db</code> flag to save your calculations:</p> <pre><code>pycusaxs -s protein.tpr -x protein.xtc -g 128 -b 0 -e 10000 \\\n    --gridS 320 --save-db\n</code></pre> <p>This saves to the default user database: <code>~/.local/share/pycusaxs/user_profiles.db</code></p>"},{"location":"user-guide/database/#custom-database-location","title":"Custom Database Location","text":"<p>Specify a custom path:</p> <pre><code>pycusaxs -s protein.tpr -x protein.xtc -g 128 --save-db /path/to/my_profiles.db\n</code></pre>"},{"location":"user-guide/database/#save-to-reference-database-maintainers-only","title":"Save to Reference Database (Maintainers Only)","text":"<p>For building the reference solvent library:</p> <pre><code>pycusaxs -s tip3p_water.tpr -x tip3p_water.xtc -g 128 -b 0 -e 50000 \\\n    --gridS 320 --save-reference\n</code></pre> <p>Warning</p> <p>The <code>--save-reference</code> flag requires write permission to the package directory and should only be used by maintainers building the reference library.</p>"},{"location":"user-guide/database/#stored-information","title":"Stored Information","text":"<p>Each profile stores:</p> <ul> <li>Solvent identification: Water model (TIP3P, TIP4P, SPC, SPCE), ion composition</li> <li>Box dimensions: x, y, z dimensions and volume</li> <li>Supercell information: Scale factor and volume</li> <li>Simulation parameters: Time analyzed, frames, stride</li> <li>SAXS parameters: Grid size, bin size, q-cutoff, order</li> <li>Profile data: Full I(q) vs q curve</li> </ul>"},{"location":"user-guide/database/#database-management-tool","title":"Database Management Tool","text":"<p>Use <code>saxs_db_tool</code> to manage profiles:</p>"},{"location":"user-guide/database/#list-profiles","title":"List Profiles","text":"<pre><code># List user profiles\npython -m pycusaxs.saxs_db_tool list\n\n# List reference profiles\npython -m pycusaxs.saxs_db_tool list --db /path/to/reference_solvents.db\n\n# Filter by water model\npython -m pycusaxs.saxs_db_tool list --water-model TIP3P\n</code></pre> <p>Example output:</p> <pre><code>================================================================================\nID    Water    Ions                 Box (\u00c5)                   Scale    Time (ps)\n--------------------------------------------------------------------------------\n1     TIP3P    Na:38, Cl:38         100.0x100.0x100.0         2.500    50000.0\n2     TIP4P    none                 80.0x80.0x80.0            2.000    25000.0\n3     SPCE     K:10, Cl:10          120.0x120.0x120.0         3.000    100000.0\n--------------------------------------------------------------------------------\nTotal profiles: 3\n</code></pre>"},{"location":"user-guide/database/#show-profile-details","title":"Show Profile Details","text":"<pre><code>python -m pycusaxs.saxs_db_tool info 1\n</code></pre> <p>Displays comprehensive information:</p> <pre><code>============================================================\nSAXS Profile Details (ID: 1)\n============================================================\n\n--- Solvent Information ---\nWater Model: TIP3P\nWater Molecules: 33216\n\nIon Composition:\n  Na\u207a: 38\n  Cl\u207b: 38\n\n--- Box Dimensions ---\nSize: 100.000 x 100.000 x 100.000 \u00c5\nVolume: 1000000.00 \u00c5\u00b3\n\n--- Supercell ---\nScale Factor: 2.5000\nSupercell Volume: 15625000.00 \u00c5\u00b3\n\n--- Simulation Parameters ---\nSimulation Time: 50000.00 ps\nFrames Analyzed: 5000\nFrame Stride: 10\n\n--- SAXS Calculation ---\nGrid Size: [128, 128, 128]\nB-Spline Order: 4\nBin Size: 0.026\nQ Cutoff: 1.5\n\n--- System Properties ---\nTotal Atoms: 99686\nDensity: 0.9820 g/cm\u00b3\n\n--- Profile Data ---\nData Points: 57\nQ Range: 0.026000 - 1.482000 \u00c5\u207b\u00b9\n</code></pre>"},{"location":"user-guide/database/#export-profile-to-csv","title":"Export Profile to CSV","text":"<pre><code>python -m pycusaxs.saxs_db_tool export 1 output.csv\n</code></pre> <p>Creates a CSV file with metadata header:</p> <pre><code># SAXS Solvent Profile\n# Water Model: TIP3P\n# Water Molecules: 33216\n# Ion Counts: {'Na': 38, 'Cl': 38}\n# Box Size: 100.000 x 100.000 x 100.000 \u00c5\n# Supercell Scale: 2.5000\n# Simulation Time: 50000.00 ps\n# Frames Analyzed: 5000\n# Density: 0.9820 g/cm\u00b3\n#\n# q (1/\u00c5), I(q) (1/\u00c5\u00b3)\n0.026000,1.234567e-03\n0.052000,9.876543e-04\n...\n</code></pre>"},{"location":"user-guide/database/#python-api","title":"Python API","text":"<p>Programmatic access to the database:</p> <pre><code>from pycusaxs.saxs_database import SaxsDatabase\n\n# Open database\nwith SaxsDatabase(\"~/.local/share/pycusaxs/user_profiles.db\") as db:\n    # List all profiles\n    profiles = db.list_profiles()\n\n    # Filter by water model\n    tip3p_profiles = db.list_profiles(water_model=\"TIP3P\")\n\n    # Find a specific profile\n    profile = db.find_profile(\n        water_model=\"TIP3P\",\n        ion_counts={'Na': 38, 'Cl': 38},\n        box_x=100.0, box_y=100.0, box_z=100.0,\n        supercell_scale=2.5\n    )\n\n    if profile:\n        print(f\"Found profile ID: {profile['id']}\")\n        q_values, i_values = zip(*profile['profile_data'])\n</code></pre>"},{"location":"user-guide/database/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Solvent Subtraction workflows</li> <li>See the CLI Guide for all command-line options</li> <li>Check Python API for programmatic access</li> </ul>"},{"location":"user-guide/gui/","title":"Graphical User Interface","text":"<p>The pyCuSAXS GUI provides an intuitive interface for configuring and running SAXS calculations without using the command line.</p>"},{"location":"user-guide/gui/#launching-the-gui","title":"Launching the GUI","text":"<p>There are two ways to launch the graphical interface:</p> <pre><code># Method 1: Using the installed command\nsaxs-widget\n\n# Method 2: Using the Python module\npython -m pycusaxs.main gui\n</code></pre> <p>No Arguments = GUI Mode</p> <p>Running <code>python -m pycusaxs.main</code> without any arguments automatically launches the GUI.</p>"},{"location":"user-guide/gui/#interface-overview","title":"Interface Overview","text":"<p>The GUI is organized into several sections:</p> <ol> <li>Required Parameters Panel - Essential input fields</li> <li>Advanced Parameters Button - Opens additional options dialog</li> <li>Run Button - Execute the SAXS calculation</li> <li>Output Display - Shows results and configuration summary</li> </ol>"},{"location":"user-guide/gui/#required-parameters-panel","title":"Required Parameters Panel","text":""},{"location":"user-guide/gui/#file-selection","title":"File Selection","text":""},{"location":"user-guide/gui/#topology-file","title":"Topology File","text":"<p>Select your GROMACS topology file (<code>.tpr</code>):</p> <ul> <li>Click Browse next to \"Topology File\"</li> <li>Navigate to your <code>.tpr</code> file</li> <li>Select and open</li> </ul>"},{"location":"user-guide/gui/#trajectory-file","title":"Trajectory File","text":"<p>Select your MD trajectory file:</p> <ul> <li>Click Browse next to \"Trajectory File\"</li> <li>Navigate to your trajectory (<code>.xtc</code>, <code>.trr</code>, etc.)</li> <li>Select and open</li> </ul> <p>File Compatibility</p> <p>The topology and trajectory must be compatible (same system). The GUI will display an error if files are incompatible.</p>"},{"location":"user-guide/gui/#grid-size","title":"Grid Size","text":"<p>Specify the density grid dimensions:</p> <p>Single Value (Cubic Grid): <pre><code>128\n</code></pre> Creates a 128\u00d7128\u00d7128 grid.</p> <p>Three Values (Non-Cubic Grid): <pre><code>128,128,256\n</code></pre> Creates a 128\u00d7128\u00d7256 grid.</p> <p>Grid Size Hints</p> <ul> <li>Start with 64 for testing</li> <li>Use 128 for production (recommended)</li> <li>Use 256 for high resolution (requires more GPU memory)</li> </ul>"},{"location":"user-guide/gui/#frame-range","title":"Frame Range","text":""},{"location":"user-guide/gui/#begin-frame","title":"Begin Frame","text":"<p>Starting frame index (0-based): <pre><code>0  (first frame)\n100  (frame 101)\n</code></pre></p>"},{"location":"user-guide/gui/#end-frame","title":"End Frame","text":"<p>Ending frame index (inclusive): <pre><code>999  (process 1000 frames if begin=0)\n</code></pre></p> <p>Frame Validation</p> <p>The GUI will validate that:</p> <ul> <li>Begin &lt; End</li> <li>Both values are within trajectory bounds</li> <li>Values are non-negative integers</li> </ul>"},{"location":"user-guide/gui/#advanced-parameters-dialog","title":"Advanced Parameters Dialog","text":"<p>Click the Advanced Parameters button to open a dialog with additional options.</p>"},{"location":"user-guide/gui/#output-settings","title":"Output Settings","text":""},{"location":"user-guide/gui/#output-file-path","title":"Output File Path","text":"<p>Specify where to save the SAXS profile:</p> <pre><code>results/saxs_profile.dat\n/path/to/output/saxs.dat\n</code></pre> <p>Default: <code>saxs.dat</code> in current directory</p>"},{"location":"user-guide/gui/#grid-settings","title":"Grid Settings","text":""},{"location":"user-guide/gui/#frame-stride-dt","title":"Frame Stride (dt)","text":"<p>Process every Nth frame:</p> <pre><code>1  - Every frame\n10 - Every 10th frame\n</code></pre> <p>Increase to reduce computation time while maintaining statistical sampling.</p>"},{"location":"user-guide/gui/#b-spline-order","title":"B-spline Order","text":"<p>Interpolation order (1-8):</p> <pre><code>4  - Standard (default)\n6  - Higher accuracy\n</code></pre> <p>Higher values provide better accuracy but slower computation.</p>"},{"location":"user-guide/gui/#scaled-grid-size","title":"Scaled Grid Size","text":"<p>Manually specify supersampled grid dimensions:</p> <pre><code>256,256,256\n</code></pre> <p>Leave empty to use automatic calculation based on Scale Factor.</p>"},{"location":"user-guide/gui/#scale-factor","title":"Scale Factor","text":"<p>Grid supersampling ratio (\u03c3):</p> <pre><code>1.0  - No oversampling (default)\n2.0  - 2\u00d7 oversampling\n</code></pre>"},{"location":"user-guide/gui/#histogram-settings","title":"Histogram Settings","text":""},{"location":"user-guide/gui/#bin-size","title":"Bin Size","text":"<p>Histogram bin width (\u00c5\u207b\u00b9):</p> <pre><code>0.01  - Standard resolution\n0.005 - Fine resolution\n</code></pre>"},{"location":"user-guide/gui/#q-cutoff","title":"Q Cutoff","text":"<p>Maximum q value (\u00c5\u207b\u00b9):</p> <pre><code>0.5  - Standard range\n1.0  - Extended range\n</code></pre>"},{"location":"user-guide/gui/#solvent-settings","title":"Solvent Settings","text":""},{"location":"user-guide/gui/#water-model","title":"Water Model","text":"<p>Select water model from dropdown:</p> <ul> <li>None (use average padding)</li> <li>tip3p</li> <li>tip4p</li> <li>spc</li> <li>spce</li> <li>Other models</li> </ul>"},{"location":"user-guide/gui/#sodium-count","title":"Sodium Count","text":"<p>Number of Na\u207a ions: <pre><code>150  (for 150 mM NaCl)\n</code></pre></p>"},{"location":"user-guide/gui/#chlorine-count","title":"Chlorine Count","text":"<p>Number of Cl\u207b ions: <pre><code>150  (for 150 mM NaCl)\n</code></pre></p>"},{"location":"user-guide/gui/#simulation-type","title":"Simulation Type","text":"<p>Select ensemble:</p> <ul> <li>NVT - Constant volume</li> <li>NPT - Constant pressure</li> </ul>"},{"location":"user-guide/gui/#running-a-calculation","title":"Running a Calculation","text":""},{"location":"user-guide/gui/#step-by-step-workflow","title":"Step-by-Step Workflow","text":"<ol> <li>Load Files</li> <li>Browse and select topology file</li> <li> <p>Browse and select trajectory file</p> </li> <li> <p>Set Grid Parameters</p> </li> <li>Enter grid size (e.g., <code>128</code>)</li> <li> <p>Set frame range (begin/end)</p> </li> <li> <p>Configure Advanced Options (Optional)</p> </li> <li>Click \"Advanced Parameters\"</li> <li>Adjust settings as needed</li> <li> <p>Click \"OK\" to save</p> </li> <li> <p>Execute</p> </li> <li>Click \"Run\" button</li> <li> <p>Wait for calculation to complete</p> </li> <li> <p>View Results</p> </li> <li>Configuration summary appears in output panel</li> <li>Timing statistics displayed</li> <li>Output file saved to specified location</li> </ol>"},{"location":"user-guide/gui/#progress-feedback","title":"Progress Feedback","text":"<p>During execution, the GUI shows:</p> <ul> <li>Configuration summary (grid sizes, parameters)</li> <li>Frame processing messages</li> <li>Timing statistics</li> <li>Success/error messages</li> </ul> <p>Completion Message</p> <p>When complete, you'll see: <pre><code>Done N Steps\nResults written to [output_file]\n\n========================================\n=          CuSAXS Timing              =\n========================================\n=   CUDA Time: XX.XX ms/per step      =\n=   Read Time: XX.XX ms/per step      =\n=   Total Time: XX.XX ms/per step     =\n========================================\n</code></pre></p>"},{"location":"user-guide/gui/#example-workflows","title":"Example Workflows","text":""},{"location":"user-guide/gui/#workflow-1-quick-test","title":"Workflow 1: Quick Test","text":"<p>For quick validation:</p> <ol> <li>Select files: <code>system.tpr</code>, <code>trajectory.xtc</code></li> <li>Grid size: <code>64</code></li> <li>Frames: Begin=<code>0</code>, End=<code>10</code></li> <li>Click Run</li> </ol> <p>Result: Fast test run on 10 frames with low-resolution grid.</p>"},{"location":"user-guide/gui/#workflow-2-standard-production","title":"Workflow 2: Standard Production","text":"<p>For typical production run:</p> <ol> <li>Select files: <code>protein.tpr</code>, <code>production.xtc</code></li> <li>Grid size: <code>128</code></li> <li>Frames: Begin=<code>0</code>, End=<code>999</code></li> <li>Advanced Parameters:</li> <li>Frame stride: <code>10</code></li> <li>Output: <code>results/saxs_profile.dat</code></li> <li>Bin size: <code>0.01</code></li> <li>Q cutoff: <code>0.5</code></li> <li>Click Run</li> </ol> <p>Result: Process 100 frames (every 10<sup>th</sup>) with standard settings.</p>"},{"location":"user-guide/gui/#workflow-3-high-accuracy-calculation","title":"Workflow 3: High-Accuracy Calculation","text":"<p>For publication-quality results:</p> <ol> <li>Select files: <code>system.tpr</code>, <code>trajectory.xtc</code></li> <li>Grid size: <code>128</code></li> <li>Frames: Begin=<code>0</code>, End=<code>999</code></li> <li>Advanced Parameters:</li> <li>Frame stride: <code>5</code></li> <li>Order: <code>6</code></li> <li>Scale factor: <code>2.0</code></li> <li>Bin size: <code>0.005</code></li> <li>Q cutoff: <code>0.5</code></li> <li>Output: <code>publication_saxs.dat</code></li> <li>Click Run</li> </ol> <p>Result: High-accuracy calculation with fine binning.</p>"},{"location":"user-guide/gui/#workflow-4-explicit-solvent","title":"Workflow 4: Explicit Solvent","text":"<p>For solvated systems:</p> <ol> <li>Select files: <code>solvated.tpr</code>, <code>md.xtc</code></li> <li>Grid size: <code>100</code></li> <li>Frames: Begin=<code>0</code>, End=<code>999</code></li> <li>Advanced Parameters:</li> <li>Water model: <code>tip3p</code></li> <li>Sodium: <code>150</code></li> <li>Chlorine: <code>150</code></li> <li>Simulation: <code>nvt</code></li> <li>Frame stride: <code>10</code></li> <li>Click Run</li> </ol> <p>Result: SAXS calculation with explicit water model and ions.</p>"},{"location":"user-guide/gui/#output-display","title":"Output Display","text":"<p>The output panel shows:</p>"},{"location":"user-guide/gui/#configuration-summary","title":"Configuration Summary","text":"<pre><code>*************************************************\n*            Running CuSAXS                     *\n* Cell Grid               128 *  128 *  128     *\n* Supercell Grid          256 *  256 *  256     *\n* Order    4          Sigma      2.000          *\n* Bin Size 0.010      Q Cutoff   0.500          *\n* Padding             avg Border                *\n*************************************************\n</code></pre>"},{"location":"user-guide/gui/#system-information","title":"System Information","text":"<pre><code>Total molecules: 50234\nProteins: 1\nWaters: 50000\nIons: 233\nOthers: 0\n</code></pre>"},{"location":"user-guide/gui/#frame-progress","title":"Frame Progress","text":"<pre><code>--&gt; Frame:    0      Time Step: 0.00 fs\n--&gt; Frame:   10      Time Step: 100.00 fs\n--&gt; Frame:   20      Time Step: 200.00 fs\n...\n</code></pre>"},{"location":"user-guide/gui/#timing-statistics","title":"Timing Statistics","text":"<pre><code>=========================================================\n=                    CuSAXS Timing                     =\n=========================================================\n=           CUDA Time:     25.43 ms/per step           =\n=           Read Time:     5.12 ms/per step            =\n=           Total Time:    30.55 ms/per step           =\n=========================================================\n</code></pre>"},{"location":"user-guide/gui/#error-handling","title":"Error Handling","text":"<p>The GUI provides informative error messages for common issues:</p>"},{"location":"user-guide/gui/#file-not-found","title":"File Not Found","text":"<pre><code>Error: Topology file not found: /path/to/file.tpr\nPlease check the file path and try again.\n</code></pre> <p>Solution: Verify file exists and path is correct.</p>"},{"location":"user-guide/gui/#invalid-frame-range","title":"Invalid Frame Range","text":"<pre><code>Error: Begin frame (1000) must be less than end frame (999)\n</code></pre> <p>Solution: Ensure begin &lt; end.</p>"},{"location":"user-guide/gui/#grid-size-error","title":"Grid Size Error","text":"<pre><code>Error: Grid size must be 1 or 3 positive integers\n</code></pre> <p>Solution: Enter either <code>128</code> or <code>128,128,128</code>.</p>"},{"location":"user-guide/gui/#calculation-error","title":"Calculation Error","text":"<pre><code>CUDA Error: Out of memory\n</code></pre> <p>Solution: Reduce grid size or close other GPU applications.</p>"},{"location":"user-guide/gui/#tips-and-best-practices","title":"Tips and Best Practices","text":"<p>Parameter Testing</p> <p>Use the GUI to test different parameter combinations quickly. Once you find optimal settings, you can use the same parameters in the CLI for batch processing.</p> <p>Save Output</p> <p>The output display shows the exact configuration used. Copy this for reproducibility or use it to construct CLI commands.</p> <p>Resource Monitoring</p> <p>Keep <code>nvidia-smi</code> running in a terminal to monitor GPU memory usage during calculations.</p> <p>Long Calculations</p> <p>For very long calculations (many frames, large grids), the GUI may appear frozen. This is normal - the calculation is still running. Check the output file for progress.</p>"},{"location":"user-guide/gui/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Shortcut Action Ctrl+O Open topology file Ctrl+T Open trajectory file Ctrl+R Run calculation Ctrl+Q Quit application"},{"location":"user-guide/gui/#integration-with-cli","title":"Integration with CLI","text":"<p>After using the GUI to determine optimal parameters, you can replicate the calculation using the CLI:</p>"},{"location":"user-guide/gui/#gui-settings","title":"GUI Settings:","text":"<ul> <li>Topology: <code>system.tpr</code></li> <li>Trajectory: <code>trajectory.xtc</code></li> <li>Grid: <code>128</code></li> <li>Begin: <code>0</code>, End: <code>999</code></li> <li>Frame stride: <code>10</code></li> <li>Order: <code>6</code></li> <li>Bin size: <code>0.01</code></li> </ul>"},{"location":"user-guide/gui/#equivalent-cli-command","title":"Equivalent CLI Command:","text":"<pre><code>python -m pycusaxs.main \\\n    -s system.tpr \\\n    -x trajectory.xtc \\\n    -g 128 \\\n    -b 0 -e 999 \\\n    --dt 10 \\\n    --order 6 \\\n    --bin 0.01 \\\n    -o saxs_profile.dat\n</code></pre>"},{"location":"user-guide/gui/#see-also","title":"See Also","text":"<ul> <li>Command Line Interface - CLI reference for batch processing</li> <li>Configuration - Detailed parameter descriptions</li> <li>Quick Start - Getting started guide</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"user-guide/python-api/","title":"Python API","text":"<p>The pyCuSAXS Python API allows you to integrate SAXS calculations into your Python scripts and workflows.</p>"},{"location":"user-guide/python-api/#overview","title":"Overview","text":"<p>The Python API provides:</p> <ul> <li>Trajectory Analysis: Load and analyze MD trajectories using MDAnalysis</li> <li>System Information: Extract molecular composition and structure</li> <li>SAXS Calculations: Run GPU-accelerated SAXS calculations programmatically</li> <li>Frame Streaming: Memory-efficient iteration over large trajectories</li> </ul>"},{"location":"user-guide/python-api/#core-modules","title":"Core Modules","text":""},{"location":"user-guide/python-api/#pycusaxstopology","title":"pycusaxs.topology","text":"<p>The <code>Topology</code> class provides trajectory handling and system analysis.</p>"},{"location":"user-guide/python-api/#pycusaxsmain","title":"pycusaxs.main","text":"<p>The <code>cuda_connect</code> function orchestrates SAXS calculations.</p>"},{"location":"user-guide/python-api/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/python-api/#basic-example","title":"Basic Example","text":"<pre><code>from pycusaxs.topology import Topology\nfrom pycusaxs.main import cuda_connect\n\n# Load topology and trajectory\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\n\n# Print system information\nprint(f\"Atoms: {topo.n_atoms}\")\nprint(f\"Frames: {topo.n_frames}\")\n\n# Get molecular composition\ntotal, protein, water, ions, other = topo.count_molecules()\nprint(f\"Proteins: {protein}, Waters: {water}, Ions: {ions}\")\n\n# Configure SAXS calculation\nrequired = {\n    \"topology\": \"system.tpr\",\n    \"trajectory\": \"trajectory.xtc\",\n    \"grid_size\": [128, 128, 128],\n    \"initial_frame\": 0,\n    \"last_frame\": 100\n}\n\nadvanced = {\n    \"dt\": 10,\n    \"order\": 4,\n    \"bin_size\": 0.01,\n    \"qcut\": 0.5,\n    \"out\": \"saxs.dat\"\n}\n\n# Run SAXS calculation\nresults = cuda_connect(required, advanced)\nfor line in results:\n    print(line)\n</code></pre>"},{"location":"user-guide/python-api/#topology-class","title":"Topology Class","text":""},{"location":"user-guide/python-api/#constructor","title":"Constructor","text":"<pre><code>from pycusaxs.topology import Topology\n\ntopo = Topology(tpr_file: str, xtc_file: str)\n</code></pre> <p>Parameters:</p> <ul> <li><code>tpr_file</code> - Path to GROMACS topology file (<code>.tpr</code>)</li> <li><code>xtc_file</code> - Path to trajectory file (<code>.xtc</code>, <code>.trr</code>, etc.)</li> </ul> <p>Example:</p> <pre><code>topo = Topology(\"system.tpr\", \"trajectory.xtc\")\n</code></pre>"},{"location":"user-guide/python-api/#properties","title":"Properties","text":""},{"location":"user-guide/python-api/#n_atoms","title":"n_atoms","text":"<p>Total number of atoms in the system.</p> <pre><code>num_atoms = topo.n_atoms\nprint(f\"System has {num_atoms} atoms\")\n</code></pre>"},{"location":"user-guide/python-api/#n_frames","title":"n_frames","text":"<p>Total number of frames in the trajectory.</p> <pre><code>num_frames = topo.n_frames\nprint(f\"Trajectory has {num_frames} frames\")\n</code></pre>"},{"location":"user-guide/python-api/#methods","title":"Methods","text":""},{"location":"user-guide/python-api/#count_molecules","title":"count_molecules()","text":"<p>Count molecules by category.</p> <pre><code>total, protein, water, ions, other = topo.count_molecules()\n</code></pre> <p>Returns: Tuple of (total, protein, water, ions, other)</p> <p>Example:</p> <pre><code>total, protein, water, ions, other = topo.count_molecules()\nprint(f\"Total molecules: {total}\")\nprint(f\"Proteins: {protein}\")\nprint(f\"Waters: {water}\")\nprint(f\"Ions: {ions}\")\nprint(f\"Others: {other}\")\n</code></pre>"},{"location":"user-guide/python-api/#get_atom_index","title":"get_atom_index()","text":"<p>Get atom indices grouped by element symbol.</p> <pre><code>atom_index = topo.get_atom_index()\n</code></pre> <p>Returns: Dictionary mapping element symbols to lists of atom indices</p> <p>Example:</p> <pre><code>atom_index = topo.get_atom_index()\nfor element, indices in atom_index.items():\n    print(f\"{element}: {len(indices)} atoms\")\n\n# Output:\n# C: 1234 atoms\n# N: 456 atoms\n# O: 789 atoms\n# H: 2345 atoms\n</code></pre>"},{"location":"user-guide/python-api/#iter_frames_stream","title":"iter_frames_stream()","text":"<p>Stream frames lazily for memory-efficient processing.</p> <pre><code>for frame_data in topo.iter_frames_stream(start, stop, step=1):\n    # Process frame\n    pass\n</code></pre> <p>Parameters:</p> <ul> <li><code>start</code> - Starting frame index (0-based)</li> <li><code>stop</code> - Ending frame index (exclusive)</li> <li><code>step</code> - Frame stride (default: 1)</li> </ul> <p>Returns: Iterator yielding dictionaries with:</p> <ul> <li><code>frame</code> - Frame number</li> <li><code>time</code> - Simulation time (ps)</li> <li><code>positions</code> - Atomic positions (NumPy array, Angstroms)</li> <li><code>box</code> - Box dimensions (Angstroms)</li> </ul> <p>Example:</p> <pre><code># Stream every 10th frame\nfor frame_data in topo.iter_frames_stream(0, 100, step=10):\n    frame_num = frame_data['frame']\n    time = frame_data['time']\n    positions = frame_data['positions']\n    box = frame_data['box']\n\n    print(f\"Frame {frame_num} at {time:.2f} ps\")\n    print(f\"  Box: {box[0]:.2f} x {box[1]:.2f} x {box[2]:.2f} \u00c5\")\n    print(f\"  Atoms: {len(positions)}\")\n</code></pre>"},{"location":"user-guide/python-api/#read_frame","title":"read_frame()","text":"<p>Load a specific frame.</p> <pre><code>timestep = topo.read_frame(frame_number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>frame_number</code> - Frame index to load (0-based)</li> </ul> <p>Returns: MDAnalysis Timestep object</p> <p>Example:</p> <pre><code># Load frame 100\nts = topo.read_frame(100)\n\n# Access frame data through getter methods\ncoords = topo.get_coordinates()\nbox = topo.get_box()\ntime = topo.get_time()\n</code></pre>"},{"location":"user-guide/python-api/#getter-methods","title":"Getter Methods","text":"<p>After calling <code>read_frame()</code>, use these methods to access frame data:</p> <pre><code># Get coordinates (NumPy array, Angstroms)\ncoords = topo.get_coordinates()\n\n# Get box dimensions (Angstroms)\nbox = topo.get_box()\n\n# Get simulation time (ps)\ntime = topo.get_time()\n\n# Get time step (ps)\nstep = topo.get_step()\n</code></pre> <p>Read Frame First</p> <p>Getter methods raise <code>RuntimeError</code> if <code>read_frame()</code> hasn't been called.</p>"},{"location":"user-guide/python-api/#saxs-calculation","title":"SAXS Calculation","text":""},{"location":"user-guide/python-api/#cuda_connect","title":"cuda_connect()","text":"<p>Run SAXS calculation with specified parameters.</p> <pre><code>from pycusaxs.main import cuda_connect\n\nresults = cuda_connect(required_params, advanced_params)\n</code></pre> <p>Parameters:</p> <ul> <li><code>required_params</code> - Dictionary of required parameters</li> <li><code>advanced_params</code> - Dictionary of optional parameters</li> </ul> <p>Returns: Iterable of output strings (configuration summary and results)</p>"},{"location":"user-guide/python-api/#required-parameters","title":"Required Parameters","text":"<pre><code>required = {\n    \"topology\": str,          # Path to topology file\n    \"trajectory\": str,        # Path to trajectory file\n    \"grid_size\": [int, int, int],  # Grid dimensions\n    \"initial_frame\": int,     # Starting frame (0-based)\n    \"last_frame\": int        # Ending frame (inclusive)\n}\n</code></pre> <p>Example:</p> <pre><code>required = {\n    \"topology\": \"/path/to/system.tpr\",\n    \"trajectory\": \"/path/to/trajectory.xtc\",\n    \"grid_size\": [128, 128, 128],\n    \"initial_frame\": 0,\n    \"last_frame\": 999\n}\n</code></pre>"},{"location":"user-guide/python-api/#advanced-parameters","title":"Advanced Parameters","text":"<pre><code>advanced = {\n    \"dt\": int,               # Frame stride (default: 1)\n    \"order\": int,            # B-spline order (default: 4)\n    \"bin_size\": float,       # Histogram bin width (\u00c5\u207b\u00b9)\n    \"qcut\": float,           # Q cutoff (\u00c5\u207b\u00b9)\n    \"scale_factor\": float,   # Grid scaling factor (default: 1.0)\n    \"scaled_grid\": [int, int, int],  # Explicit scaled grid\n    \"water_model\": str,      # Water model (e.g., \"tip3p\")\n    \"sodium\": int,           # Number of Na\u207a ions\n    \"chlorine\": int,         # Number of Cl\u207b ions\n    \"simulation\": str,       # \"nvt\" or \"npt\"\n    \"out\": str              # Output file path\n}\n</code></pre> <p>Example:</p> <pre><code>advanced = {\n    \"dt\": 10,\n    \"order\": 6,\n    \"bin_size\": 0.01,\n    \"qcut\": 0.5,\n    \"scale_factor\": 2.0,\n    \"out\": \"saxs_profile.dat\",\n    \"simulation\": \"nvt\"\n}\n</code></pre>"},{"location":"user-guide/python-api/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/python-api/#example-1-system-analysis","title":"Example 1: System Analysis","text":"<p>Analyze trajectory without running SAXS:</p> <pre><code>from pycusaxs.topology import Topology\n\n# Load system\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\n\n# System information\nprint(f\"System: {topo.n_atoms} atoms, {topo.n_frames} frames\")\n\n# Molecular composition\ntotal, protein, water, ions, other = topo.count_molecules()\nprint(f\"\\nMolecular Composition:\")\nprint(f\"  Proteins: {protein}\")\nprint(f\"  Waters: {water}\")\nprint(f\"  Ions: {ions}\")\nprint(f\"  Others: {other}\")\n\n# Element distribution\natom_index = topo.get_atom_index()\nprint(f\"\\nElement Distribution:\")\nfor element in sorted(atom_index.keys()):\n    count = len(atom_index[element])\n    print(f\"  {element}: {count} atoms\")\n</code></pre>"},{"location":"user-guide/python-api/#example-2-frame-analysis","title":"Example 2: Frame Analysis","text":"<p>Process individual frames:</p> <pre><code>from pycusaxs.topology import Topology\nimport numpy as np\n\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\n\n# Analyze specific frames\nfor frame_num in [0, 100, 200, 300]:\n    topo.read_frame(frame_num)\n\n    coords = topo.get_coordinates()\n    box = topo.get_box()\n    time = topo.get_time()\n\n    # Calculate center of mass\n    com = np.mean(coords, axis=0)\n\n    print(f\"Frame {frame_num} (t={time:.1f} ps):\")\n    print(f\"  Box: {box[0]:.1f} x {box[1]:.1f} x {box[2]:.1f} \u00c5\")\n    print(f\"  COM: {com[0]:.1f}, {com[1]:.1f}, {com[2]:.1f} \u00c5\")\n</code></pre>"},{"location":"user-guide/python-api/#example-3-streaming-large-trajectories","title":"Example 3: Streaming Large Trajectories","text":"<p>Memory-efficient processing:</p> <pre><code>from pycusaxs.topology import Topology\nimport numpy as np\n\ntopo = Topology(\"system.tpr\", \"large_trajectory.xtc\")\n\n# Stream frames without loading entire trajectory\nbox_volumes = []\n\nfor frame_data in topo.iter_frames_stream(0, topo.n_frames, step=10):\n    box = frame_data['box']\n    volume = np.prod(box[:3])  # Box volume\n    box_volumes.append(volume)\n\n    if frame_data['frame'] % 100 == 0:\n        print(f\"Processed frame {frame_data['frame']}\")\n\n# Statistics\nmean_vol = np.mean(box_volumes)\nstd_vol = np.std(box_volumes)\nprint(f\"\\nBox Volume: {mean_vol:.1f} \u00b1 {std_vol:.1f} \u00c5\u00b3\")\n</code></pre>"},{"location":"user-guide/python-api/#example-4-batch-saxs-calculations","title":"Example 4: Batch SAXS Calculations","text":"<p>Run multiple calculations:</p> <pre><code>from pycusaxs.main import cuda_connect\n\n# Common parameters\nbase_required = {\n    \"topology\": \"system.tpr\",\n    \"trajectory\": \"trajectory.xtc\",\n    \"grid_size\": [128, 128, 128]\n}\n\nbase_advanced = {\n    \"dt\": 10,\n    \"order\": 6,\n    \"bin_size\": 0.01,\n    \"qcut\": 0.5\n}\n\n# Process different frame ranges\nframe_ranges = [\n    (0, 249, \"saxs_0-249.dat\"),\n    (250, 499, \"saxs_250-499.dat\"),\n    (500, 749, \"saxs_500-749.dat\"),\n    (750, 999, \"saxs_750-999.dat\")\n]\n\nfor start, end, output in frame_ranges:\n    print(f\"\\nProcessing frames {start}-{end}...\")\n\n    required = base_required.copy()\n    required[\"initial_frame\"] = start\n    required[\"last_frame\"] = end\n\n    advanced = base_advanced.copy()\n    advanced[\"out\"] = output\n\n    try:\n        results = cuda_connect(required, advanced)\n        for line in results:\n            print(line)\n        print(f\"Saved to {output}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/python-api/#example-5-parameter-scan","title":"Example 5: Parameter Scan","text":"<p>Scan grid sizes for optimal parameters:</p> <pre><code>from pycusaxs.main import cuda_connect\nimport time\n\n# Test different grid sizes\ngrid_sizes = [64, 96, 128, 160, 192]\n\nresults_summary = []\n\nfor grid_size in grid_sizes:\n    print(f\"\\nTesting grid size: {grid_size}\u00b3\")\n\n    required = {\n        \"topology\": \"system.tpr\",\n        \"trajectory\": \"trajectory.xtc\",\n        \"grid_size\": [grid_size, grid_size, grid_size],\n        \"initial_frame\": 0,\n        \"last_frame\": 10  # Small test\n    }\n\n    advanced = {\n        \"dt\": 1,\n        \"out\": f\"test_grid_{grid_size}.dat\"\n    }\n\n    start_time = time.time()\n\n    try:\n        results = list(cuda_connect(required, advanced))\n        elapsed = time.time() - start_time\n\n        results_summary.append({\n            'grid': grid_size,\n            'time': elapsed,\n            'success': True\n        })\n\n        print(f\"  Time: {elapsed:.2f} s\")\n        print(f\"  Time per frame: {elapsed/11*1000:.2f} ms\")\n\n    except Exception as e:\n        print(f\"  Error: {e}\")\n        results_summary.append({\n            'grid': grid_size,\n            'time': None,\n            'success': False\n        })\n\n# Print summary\nprint(\"\\n\" + \"=\"*50)\nprint(\"Grid Size Performance Summary\")\nprint(\"=\"*50)\nfor result in results_summary:\n    if result['success']:\n        print(f\"{result['grid']:3d}\u00b3: {result['time']:6.2f} s \"\n              f\"({result['time']/11*1000:6.2f} ms/frame)\")\n    else:\n        print(f\"{result['grid']:3d}\u00b3: FAILED\")\n</code></pre>"},{"location":"user-guide/python-api/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/python-api/#exception-types","title":"Exception Types","text":"<pre><code>try:\n    results = cuda_connect(required, advanced)\n    for line in results:\n        print(line)\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid parameter: {e}\")\nexcept RuntimeError as e:\n    print(f\"Calculation error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"user-guide/python-api/#validation-example","title":"Validation Example","text":"<pre><code>from pathlib import Path\nfrom pycusaxs.main import cuda_connect\n\ndef safe_saxs_calculation(tpr_path, xtc_path, output_path):\n    \"\"\"Run SAXS with comprehensive error handling.\"\"\"\n\n    # Validate input files\n    tpr = Path(tpr_path)\n    xtc = Path(xtc_path)\n\n    if not tpr.exists():\n        raise FileNotFoundError(f\"Topology not found: {tpr}\")\n    if not xtc.exists():\n        raise FileNotFoundError(f\"Trajectory not found: {xtc}\")\n\n    # Configure calculation\n    required = {\n        \"topology\": str(tpr.resolve()),\n        \"trajectory\": str(xtc.resolve()),\n        \"grid_size\": [128, 128, 128],\n        \"initial_frame\": 0,\n        \"last_frame\": 100\n    }\n\n    advanced = {\n        \"dt\": 10,\n        \"out\": output_path\n    }\n\n    # Run with error handling\n    try:\n        results = cuda_connect(required, advanced)\n        return list(results)\n    except ValueError as e:\n        print(f\"Parameter error: {e}\")\n        raise\n    except RuntimeError as e:\n        print(f\"Backend error: {e}\")\n        raise\n\n# Usage\ntry:\n    output = safe_saxs_calculation(\n        \"system.tpr\",\n        \"trajectory.xtc\",\n        \"output/saxs.dat\"\n    )\n    print(\"\\n\".join(output))\nexcept Exception as e:\n    print(f\"Calculation failed: {e}\")\n    exit(1)\n</code></pre>"},{"location":"user-guide/python-api/#integration-with-workflows","title":"Integration with Workflows","text":""},{"location":"user-guide/python-api/#jupyter-notebook-example","title":"Jupyter Notebook Example","text":"<pre><code># Cell 1: Import and setup\nfrom pycusaxs.topology import Topology\nfrom pycusaxs.main import cuda_connect\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Cell 2: Load and analyze topology\ntopo = Topology(\"system.tpr\", \"trajectory.xtc\")\ntotal, protein, water, ions, other = topo.count_molecules()\n\nprint(f\"System: {topo.n_atoms} atoms, {topo.n_frames} frames\")\nprint(f\"Composition: {protein} proteins, {water} waters, {ions} ions\")\n\n# Cell 3: Run SAXS\nrequired = {\n    \"topology\": \"system.tpr\",\n    \"trajectory\": \"trajectory.xtc\",\n    \"grid_size\": [128, 128, 128],\n    \"initial_frame\": 0,\n    \"last_frame\": 100\n}\n\nadvanced = {\n    \"dt\": 10,\n    \"order\": 6,\n    \"bin_size\": 0.01,\n    \"qcut\": 0.5,\n    \"out\": \"saxs.dat\"\n}\n\nresults = cuda_connect(required, advanced)\nfor line in results:\n    print(line)\n\n# Cell 4: Plot results\ndata = np.loadtxt('saxs.dat')\nq = data[:, 0]\nI = data[:, 1]\n\nplt.figure(figsize=(10, 6))\nplt.loglog(q, I, 'b-', linewidth=2)\nplt.xlabel('q (\u00c5\u207b\u00b9)', fontsize=14)\nplt.ylabel('I(q) (a.u.)', fontsize=14)\nplt.title('SAXS Profile', fontsize=16)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/python-api/#see-also","title":"See Also","text":"<ul> <li>Backend API - C++/CUDA backend reference</li> <li>Python API Reference - Complete Python API documentation</li> <li>CLI Guide - Command-line interface</li> <li>Examples - Quick start examples</li> </ul>"},{"location":"user-guide/solvent-subtraction/","title":"Solvent Subtraction","text":"<p>Extract pure protein SAXS profiles by subtracting solvent contributions.</p>"},{"location":"user-guide/solvent-subtraction/#overview","title":"Overview","text":"<p>pyCuSAXS provides tools to separate protein and solvent contributions:</p> <p>I<sub>protein</sub>(q) = I<sub>total</sub>(q) - I<sub>solvent</sub>(q)</p> <p>This is achieved using a two-database system:</p> <ol> <li>Reference Database: Pure solvent profiles (read-only, shipped with package)</li> <li>User Database: Your protein+solvent calculations (read-write)</li> </ol>"},{"location":"user-guide/solvent-subtraction/#workflow","title":"Workflow","text":"<pre><code>graph TD\n    A[Pure Solvent Simulation] --&gt; B[Reference Database]\n    C[Protein+Solvent Simulation] --&gt; D[User Database]\n    B --&gt; E[Subtraction Tool]\n    D --&gt; E\n    E --&gt; F[Pure Protein Profile]</code></pre>"},{"location":"user-guide/solvent-subtraction/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"user-guide/solvent-subtraction/#step-1-check-reference-database","title":"Step 1: Check Reference Database","text":"<p>List available reference solvents:</p> <pre><code>python -m pycusaxs.saxs_db_tool list \\\n    --db /path/to/pyCuSaxs/data/reference_solvents.db\n</code></pre> <p>Example output:</p> <pre><code>ID    Water    Ions    Box (\u00c5)              Scale    Time (ps)\n1     TIP3P    none    100.0x100.0x100.0    2.500    50000.0\n2     TIP4P    none    100.0x100.0x100.0    2.500    50000.0\n3     SPC      none    100.0x100.0x100.0    2.500    50000.0\n4     SPCE     none    100.0x100.0x100.0    2.500    50000.0\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#step-2-calculate-proteinsolvent-saxs","title":"Step 2: Calculate Protein+Solvent SAXS","text":"<p>Run your protein+solvent system:</p> <pre><code>pycusaxs -s lysozyme_tip3p.tpr -x lysozyme_tip3p.xtc \\\n    -g 128 -b 0 -e 10000 --gridS 320 \\\n    -o lysozyme_total.dat \\\n    --save-db\n</code></pre> <p>This:</p> <ul> <li>Calculates SAXS for entire system (protein + TIP3P water)</li> <li>Saves profile to <code>lysozyme_total.dat</code></li> <li>Stores metadata in user database</li> </ul>"},{"location":"user-guide/solvent-subtraction/#step-3-verify-your-profile","title":"Step 3: Verify Your Profile","text":"<p>Check what was saved:</p> <pre><code>python -m pycusaxs.saxs_db_tool list\n</code></pre> <p>Example output:</p> <pre><code>ID    Water    Ions    Box (\u00c5)              Scale    Time (ps)\n1     TIP3P    Na:38   100.0x100.0x100.0    2.500    10000.0\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#step-4-subtract-solvent","title":"Step 4: Subtract Solvent","text":"<p>Extract pure protein contribution:</p> <pre><code>python -m pycusaxs.saxs_subtract \\\n    --protein-id 1 \\\n    --solvent-id 1 \\\n    -o lysozyme_protein.dat\n</code></pre> <p>Arguments:</p> <ul> <li><code>--protein-id 1</code>: Your lysozyme profile (from user database)</li> <li><code>--solvent-id 1</code>: TIP3P reference (from reference database)</li> <li><code>-o lysozyme_protein.dat</code>: Output file for pure protein profile</li> </ul> <p>Output:</p> <pre><code>Subtraction completed successfully!\nInput: Protein+Solvent (ID 1) - Solvent (ID 1)\nOutput: lysozyme_protein.dat\nData points: 57\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#step-5-analyze-result","title":"Step 5: Analyze Result","text":"<p>The output file <code>lysozyme_protein.dat</code> contains:</p> <pre><code># SAXS Profile Subtraction\n# Protein+Solvent Profile ID: 1 (from user database)\n#   Water Model: TIP3P\n#   Box: 100.0 x 100.0 x 100.0 \u00c5\n#   Supercell Scale: 2.5000\n#\n# Pure Solvent Profile ID: 1 (from reference database)\n#   Water Model: TIP3P\n#   Box: 100.0 x 100.0 x 100.0 \u00c5\n#   Supercell Scale: 2.5000\n#\n# Result: I_protein(q) = I_total(q) - I_solvent(q)\n#\n# q (1/\u00c5), I(q) (1/\u00c5\u00b3)\n0.026000  1.234567e-02\n0.052000  9.876543e-03\n...\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#alternative-file-based-subtraction","title":"Alternative: File-Based Subtraction","text":"<p>If you prefer working with .dat files directly:</p> <pre><code>python -m pycusaxs.saxs_subtract \\\n    --protein-file lysozyme_total.dat \\\n    --solvent-file tip3p_reference.dat \\\n    -o lysozyme_protein.dat\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#important-considerations","title":"Important Considerations","text":""},{"location":"user-guide/solvent-subtraction/#matching-conditions","title":"Matching Conditions","text":"<p>For accurate subtraction, ensure:</p> <p>\u2705 Same water model (TIP3P, TIP4P, SPC, SPCE) \u2705 Similar box size (interpolation handles small differences) \u2705 Same supercell scale factor \u2705 Similar simulation length (better statistics)</p>"},{"location":"user-guide/solvent-subtraction/#box-size-tolerance","title":"Box Size Tolerance","text":"<p>The subtraction tool automatically interpolates profiles, so small box size differences are acceptable:</p> <pre><code># Reference: 100 \u00c5 box\n# Your system: 98 \u00c5 box\n# \u2713 Subtraction will work (2% difference, interpolated)\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#ion-handling","title":"Ion Handling","text":"<p>If your protein system contains ions:</p> <ul> <li>Reference should be pure water (no ions)</li> <li>Subtraction yields: protein + ion contributions</li> <li>For most cases, ion contribution is negligible</li> </ul>"},{"location":"user-guide/solvent-subtraction/#volume-normalization","title":"Volume Normalization","text":"<p>Both profiles must be volume-normalized (pyCuSAXS does this automatically):</p> <ul> <li>I(q) is in units of 1/\u0172 (per unit volume)</li> <li>Ensures proper subtraction regardless of system size</li> </ul>"},{"location":"user-guide/solvent-subtraction/#complete-example","title":"Complete Example","text":"<pre><code># === User: Complete workflow ===\n\n# 1. Calculate protein+solvent\npycusaxs -s lysozyme.tpr -x lysozyme.xtc \\\n    -g 128 -b 0 -e 10000 --gridS 320 --save-db\n\n# 2. Check your profiles\npython -m pycusaxs.saxs_db_tool list\n# Output: ID 1, TIP3P system\n\n# 3. Check reference database\npython -m pycusaxs.saxs_db_tool list \\\n    --db /path/to/data/reference_solvents.db\n# Output: ID 1 is TIP3P\n\n# 4. Subtract\npython -m pycusaxs.saxs_subtract \\\n    --protein-id 1 --solvent-id 1 -o lysozyme_only.dat\n\n# 5. Done! lysozyme_only.dat contains pure protein scattering\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/solvent-subtraction/#q-which-reference-solvent-should-i-use","title":"Q: Which reference solvent should I use?","text":"<p>A: Match the water model in your protein simulation:</p> <ul> <li>Protein in TIP3P \u2192 Use reference ID for TIP3P</li> <li>Protein in TIP4P \u2192 Use reference ID for TIP4P</li> </ul> <p>Check with:</p> <pre><code>python -m pycusaxs.saxs_db_tool info 1  # Check your protein system\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#q-what-if-i-used-a-different-box-size","title":"Q: What if I used a different box size?","text":"<p>A: No problem! The tool interpolates:</p> <pre><code># Reference: 100 \u00c5 box\n# Your system: 85 \u00c5 box\n# \u2713 Works fine (interpolated automatically)\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#q-can-i-subtract-from-a-dat-file-instead","title":"Q: Can I subtract from a .dat file instead?","text":"<p>A: Yes! Use file mode:</p> <pre><code>python -m pycusaxs.saxs_subtract \\\n    --protein-file my_protein.dat \\\n    --solvent-file reference.dat \\\n    -o result.dat\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#q-the-subtracted-intensity-goes-negative","title":"Q: The subtracted intensity goes negative!","text":"<p>A: This can happen if:</p> <ul> <li>Wrong solvent model used (check water model matches)</li> <li>Protein system has different density</li> <li>Statistical noise at high q</li> </ul> <p>Solution: Ensure water models match and check system composition.</p>"},{"location":"user-guide/solvent-subtraction/#command-reference","title":"Command Reference","text":""},{"location":"user-guide/solvent-subtraction/#subtract-database-mode","title":"Subtract (Database Mode)","text":"<pre><code>python -m pycusaxs.saxs_subtract \\\n    --protein-id &lt;ID&gt; \\       # From user database\n    --solvent-id &lt;ID&gt; \\       # From reference database\n    -o output.dat             # Output file\n</code></pre> <p>Optional:</p> <pre><code>    --user-db &lt;path&gt;          # Custom user database\n    --reference-db &lt;path&gt;     # Custom reference database\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#subtract-file-mode","title":"Subtract (File Mode)","text":"<pre><code>python -m pycusaxs.saxs_subtract \\\n    --protein-file &lt;file&gt; \\   # Protein+solvent .dat\n    --solvent-file &lt;file&gt; \\   # Pure solvent .dat\n    -o output.dat             # Output file\n</code></pre>"},{"location":"user-guide/solvent-subtraction/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Database Management</li> <li>See CLI Guide for calculation options</li> <li>Check Python API for programmatic access</li> </ul>"}]}